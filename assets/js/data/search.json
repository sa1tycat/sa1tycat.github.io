[ { "title": "test", "url": "/posts/test2/", "categories": "", "tags": "", "date": "2022-10-18 20:45:23 +0800", "snippet": "this is a test2$x, y$" }, { "title": "test", "url": "/posts/test/", "categories": "", "tags": "", "date": "2022-10-18 20:45:23 +0800", "snippet": "this is a test$x, y![16641673349112.pic](/assets/blog_res/2022-10-18-test.assets/16641673349112.pic.jpg)" }, { "title": "1，2，3，4 依次入栈的出栈排列问题", "url": "/posts/stack-combinatory/", "categories": "算法, 数据结构", "tags": "栈", "date": "2022-10-18 20:45:23 +0800", "snippet": "" }, { "title": "时间复杂度", "url": "/posts/time-complexity/", "categories": "算法", "tags": "时间复杂度", "date": "2022-08-31 19:26:17 +0800", "snippet": "记号大 O 记号用于描述一个函数的渐进上界。具体地，若存在正的常数 $c$ 和函数 $f(n)$，使得对任何 $n \\gg 2$ 都有 $T(n) \\leq c\\cdot f(n)$ 则可认为在 $n$ 足够大之后，$f(n)$ 给出了 $T(n)$ 增长速度的一个渐进上界。此时，记之为： $T(n) = \\mathcal{O}(f(n))$。其性质： 对于任一常数 $c &gt; 0$，有 $\\mathcal{O}(f(n)) = \\mathcal{O}(c\\cdot f(n))$ 对于任意常数 $a &gt; b &gt; 0$，有 $\\mathcal{O}(n^a + n^b) = \\mathcal{O}(n^a)$从而可知大 O 记号将正的常数认定为 1，并且忽略除最高次项的其他项。由于大 O 记号用于刻画的是一个函数的渐进上界，对于时间复杂度为 $T(n)=4n^3+2n$ 的函数，也可以被记作 $\\mathcal{O}(n^5)$。但通常就直接取次数最高项。大 Ω 记号若存在正的常数 $c$ 和函数 $f(n)$，使得对任何 $n \\gg 2$ 都有 $T(n) \\geq c\\cdot f(n)$ 则可认为在 $n$ 足够大之后，$f(n)$ 给出了 $T(n)$ 增长速度的一个渐进下界。此时，记之为： $T(n) = \\textup{Ω}(f(n))$。不同于大 O 记号，大 Ω 记号用于刻画一个算法运行的最好情况，即算法运行时间都不低于 $\\textup{Ω}(f(n))$。大 Θ 记号$T(n)$ 介于 $\\Omega(g(n))$与 $\\mathcal{O}(f(n))$ 之间。若恰巧出现 $g(n) = f(n)$ 的情况，则可以使用另一记号来表示。如果存在正的常数 $c_1 &lt; c_2$ 和函数 $h(n)$，使得对于任何 $n \\gg 2$ 都有 $c_1\\cdot h(n) \\leq T(n) \\leq c_2\\cdot h(n)$ 就可以认为在 $n$ 足够大之后，$h(n)$ 给出了 $T(n)$ 的一个确界。此时，我们记之为： $T(n) = \\Theta(h(n))$。大 Θ 记号是对算法复杂度的准确估计，对于规模为 $n$ 的任何输入，算法的运行时间 $T(n)$ 都与 $\\Theta(h(n))$ 同阶。由于大 Θ 记号的条件较强，故在某些情况下，可能无法找到这个紧贴的 $h(n)$，因此多数情况下我们都直接使用 $\\mathcal{O}$ 来描述一个算法的时间复杂度。常见时间复杂度常数 $\\mathcal{O}(1)$一般地，仅含一次或常数次基本操作的算法均属此类。此类算法通常不含循环、分支、子程序调用等，但也不能仅凭语法结构的表面形式一概而论。线性 $\\mathcal{O}(n)$如：long long power(int a, int n) { long long ret = 1; // O(1) for (int i = 0; i &lt; n; i++) { // O(n) ret *= a; // O(1) } return ret; // O(1)}的时间复杂度为： $\\mathcal{O}(1)+\\mathcal{O}(1)\\cdot \\mathcal{O}(n)+\\mathcal{O}(1)=\\mathcal{O}(n+2)=\\mathcal{O}(n)$。对于输入的每一单元，此类算法平均消耗常数时间。就大多数问题而言，在对输入的每一单元均至少访问一次之前，不可能得出解答。以数组求和为例，在尚未得知每一元素的具体数值之前，绝不可能确定其总和。故就此意义而言，此类算法的效率亦足以令人满意。对数 $\\mathcal{O}(\\log n)$如：long long power(int a, int n) { long long tmp = 1; while (n &gt; 0) { // O(log n) if (n &amp; 1) { // O(1) tmp *= a; // O(1) } a = a * a; // O(1) n &gt;&gt;= 1; // O(1) } return tmp; // O(1)}的复杂度为 $\\mathcal{O}(\\log n)$。注意：根据换底公式和大 O 记号的性质，有 $\\mathcal{O}(\\log_a n)=\\mathcal{O}(\\frac{1}{\\log a}\\cdot \\log n)=\\mathcal{O}(\\log n)$，故一般省略对数底数简写成 $\\mathcal{O}(\\log n)$。多项式 $\\mathcal{O}(n^k)$若运行时间可以表示和度量为 $T(n) = \\mathcal{O}(f(n))$ 的形式，而且 $f(x)$ 为多项式，则对应的算法称作“多项式时间复杂度算法”（polynomial-time algorithm）。当然，线性时间复杂度算法，也属于多项式时间复杂度算法的特例，其中线性多项式 $f(n) = n$ 的次数为1。在算法复杂度理论中，多项式时间复杂度被视作一个具有特殊意义的复杂度级别。多项式级的运行时间成本，在实际应用中一般被认为是可接受的或可忍受的。某问题若存在一个复杂度在此范围以内的算法，则称该问题是可有效求解的或易解的（tractable）。请注意，这里仅要求多项式的次数为一个正的常数，而并未对其最大取值范围设置任何具体上限，故实际上该复杂度级别涵盖了很大的一类算法。比如，从理论上讲，复杂度分别为 $\\mathcal{O}(n^2)$ 和 $\\mathcal{O}(n^{1000})$ 算法都同属此类，尽管二者实际的计算效率有天壤之别。之所以如此，是因为相对于以下的指数级复杂度，二者之间不超过多项式规模的差异只是小巫见大巫。指数 $\\mathcal{O}(2^n)$如：long long fib(int n) { return n &lt;= 1 ? 1 : fib(n - 1) + fib(n - 2);}$T(n) = \\mathcal{O}(\\Phi^{n+1}) = \\mathcal{O}(2^n)$由于指数增量过大，很难在实际中有效解决问题，因此指数级的“算法”也被称作难解（intractable）问题。时间复杂度分析常见的求和公式 自然等幂级数\\[\\sum^{n}_{i=1} i = \\frac{n(n+1)}{2}=\\mathcal{O}(n^{2})\\]\\[\\sum _{i=1}^{n}i^2={\\frac {1}{3}}n^{3}+{\\frac {1}{2}}n^{2}+{\\frac {1}{6}}n=\\mathcal{O}(n^{3})\\]\\[\\sum _{i=1}^{n}i^3={\\frac {1}{4}}n^{4}+{\\frac {1}{2}}n^{3}+{\\frac {1}{4}}n^{2}=\\mathcal{O}(n^{4})\\]\\[\\sum _{i=1}^{n}i^4={\\frac {1}{5}}n^{5}+{\\frac {1}{2}}n^{4}+{\\frac {1}{3}}n^{3}-{\\frac {1}{30}}n=\\mathcal{O}(n^{5})\\]\\[\\sum _{i=0}^{n}i^{k}\\approx \\int_{0}^{n} x^k\\, dx=\\mathcal{O}(n^{k+1})\\] 几何级数\\[\\sum _{i=0}^{n}a^{k}=\\frac{a^{n+1}-1}{a-1} =\\mathcal{O}(a^{n})\\;(a&gt;1)\\] 收敛级数\\[\\sum _{i=2}^{n}\\frac{1}{i\\cdot(i-1)}=1-\\frac{1}{n} =\\mathcal{O}(1)\\]\\[\\sum _{i=1}^{n}\\frac{1}{i^2}=\\frac{\\pi^2}{6} =\\mathcal{O}(1)\\]\\[\\sum _{i\\textup{ is a perfect power}}\\frac{1}{i-1}=\\frac{1}{3}+\\frac{1}{7}+\\frac{1}{8}\\dots=1=\\mathcal{O}(1)\\]\\[\\textup{几何分布: }(1-\\lambda)\\cdot(1+2\\lambda+3\\lambda^2+4\\lambda^3+\\dots)=\\frac{1}{1-\\lambda}=\\mathcal{O}(1)\\;(0&lt;\\lambda&lt;1)\\] 调和级数\\[\\sum_{k=1}^n\\,\\frac{1}{k} \\;=\\; \\ln n + \\gamma + \\mathcal{O}(\\frac{1}{2n})=\\Theta(\\log n)\\] 对数级数\\[\\sum_{k=1}^n\\,\\ln k \\;=\\Theta(n\\log n)\\] 线性对数\\(\\sum_{k=1}^n\\,k\\cdot \\log k \\;\\approx\\int_1^nx\\ln x\\,dx=\\mathcal{O}(n^2\\log n)\\) 线性指数 \\[\\sum_{k=1}^n\\,k\\cdot 2^ k =\\mathcal{O}(n\\cdot2^n)\\]常用分析方法非递归算法基本步骤：1) 决定用哪个（或哪些）参数作为算法问题规模的度量 2) 找出算法中的基本语句（作为一个规律，它总是位于算法最内层循环中）3) 检查基本语句的执行次数是否只依赖于问题规模4) 建立基本语句执行次数的求和表达式 5) 用渐进符号表示这个求和表达式（1）for / while 循环 循环体内计算时间*循环次数；（2）嵌套循环 循环体内计算时间*所有循环次数；（3）顺序语句 各语句计算时间相加；（4）if-else语句 if语句计算时间和else语句计算时间的较大者。递归算法根据递归方式，列出关于时间 $T(n)$ 的递推方程，并解之。解时间递推方程的方法有：1. 展开法（归纳法）；2. 递归树法（recursion trace）；3. Master 定理展开法例如，递推式\\(T(n)=\\left\\{\\begin{matrix} 1 &amp; n=1\\\\ 2\\,T(n/2)+4n^2 &amp; n&gt;1 \\end{matrix}\\right.\\)的时间复杂度为\\[\\begin{aligned}T(n) &amp; = 2\\,T(n/2)+5n^2 \\\\&amp; =2\\,(2\\,T(n/4)+5(n/2)^2)+5n^2 \\\\&amp; =2\\,(2\\,(2\\,T(n/8)+5(n/4)^2)+5(n/2)^2)+5n^2 \\\\&amp; \\dots \\\\&amp; = 2^k\\cdot T(1)+2^{k-1}\\cdot 5 \\cdot(\\frac{n}{2^{k-1}})^2+\\dots+5n^2 \\\\&amp; = \\mathcal{O}(n^2)\\end{aligned}\\]递归树法对于程序：int sum(int a[], int n) { return n == 0 ? 0 : sum(a, n - 1) + a[n - 1];}可以画出递归图：每一个递归实例的时间复杂度为 $\\mathcal{O}(1)$，故算法的整体时间复杂度为 $\\mathcal{O}(1)\\times\\mathcal{O}(n+1)=\\mathcal{O}(n)$又如：int sum(int A[], int lo, int hi) { if (lo == hi) return A[lo]; int mi = (lo + hi) &gt;&gt; 1; return sum(A, lo, mi) + sum(A, mi+1, hi);} // 入口形式为sum(A, 0, n-1)画出递归图：每一个递归实例的复杂度均为 $\\mathcal{O}(1)$，只需统计出递归实例的个数即可，可以看到第一层有 $2^0$ 个，第二层有 $2^1$个，…，一共有 $\\lceil \\log n \\rceil$ 层，即最后一层的个数为 $2^{\\log n}$ 个，故最后总数为 $2^0+2^1+\\dots+2^{\\log n}$，也就是说：\\[\\begin{align} T(n) &amp; = \\mathcal{O}(1) \\times \\mathcal{O}(2^0+2^1+\\dots+2^{\\log n})\\\\&amp; = \\mathcal{O}(2^{\\log n}) \\\\&amp; = \\mathcal{O}(n)\\end{align}\\]Master Theorem对于形如：\\(T(n)=a\\cdot T(n/b)+\\mathcal{O}(f(n))\\)其中 $a\\cdot T(n/b)$ 对应着 $\\mathcal{O}(n^{\\log_ba})$， 若 $f(n)=\\mathcal{O}(n^{\\log_b a\\textcolor[rgb]{1,0,0}{-\\epsilon}})$，即 $\\mathcal{O}(f(n))&lt;\\mathcal{O}(n^{\\log_b a-\\epsilon})$，则 $T(n)=\\Theta(n^{\\log_b a})$ 若 $f(n)=\\Omega (n^{\\log_b a\\textcolor[rgb]{1,0,0}{+\\epsilon}})$，即 $\\mathcal{O}(f(n))&gt;\\mathcal{O}(n^{\\log_b a-\\epsilon})$，则 $T(n)=\\Theta(f(n))$ 若 $f(n)=\\Theta (n^{\\log_b a}\\cdot\\log^k n)$，即 $\\mathcal{O}(f(n))\\sim \\mathcal{O}(n^{\\log_b a})$，则 $T(n)=\\Theta(n^{\\log_b a}\\cdot\\log^{k+1} n)$如，求 \\(T(n)=\\left\\{\\begin{matrix} 1 &amp; n=1\\\\ 2\\,T(n/2)+4n &amp; n&gt;1 \\end{matrix}\\right.\\) 的时间复杂度。可知 $a=b=2$，即 $\\log_ba=\\log_22=1,\\;n^{\\log_ba}=n,\\;f(n)=4n$，故 $\\mathcal{O}(f(n))\\sim \\mathcal{O}(n^{\\log_b a})$，其中 $k=0$，故 $T(n)=\\Theta(n\\log n)$。又如，求 \\(T(n)=\\left\\{\\begin{matrix} 1 &amp; n=1\\\\ 2\\,T(n/2)+n\\log n &amp; n&gt;1 \\end{matrix}\\right.\\) 的时间复杂度。可知 $a=b=2$，即 $\\log_ba=\\log_22=1,\\;n^{\\log_ba}=n,\\;f(n)=n\\log n$，也就是说 $f(n)=\\Theta(n\\cdot \\log n)$，即 $k=1$，故 $\\mathcal{O}(f(n))\\sim \\mathcal{O}(n^{\\log_b a})$，其中 $k=1$，故 $T(n)=\\Theta(n\\log^2 n)$。实例实例一for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; i * i; j++) for (int k = 0; k &lt; j; k++) sum++;可以看到是很平凡的循环，基本操作为 sum++;，显然有：\\[\\begin{aligned}T(n) &amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\,\\sum_{j\\,=\\,0}^{i^2}\\,\\sum_{k\\,=\\,0}^{j\\,-\\,1}\\,1 \\\\\\\\&amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\,\\sum_{j\\,=\\,0}^{i^2}\\,j\\\\\\\\&amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\,(0+1+2+\\dots+i^2)\\\\\\\\&amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\,\\frac{i^2\\cdot(i^2+1)}{2}\\\\\\\\&amp; = \\mathcal{O}(n^5)\\end{aligned}\\]实例二for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; i * i; j++) if (j % i == 0) for (int k = 0; k &lt; j; k++) sum++;只有在 j 能够被 i 整除的时候才会进行基本操作 sum++，上述循环等价于：for (int i = 0; i &lt; n; i++) for (int r = 0; r &lt; i; j++) for (int k = 0; k &lt; r * i; k++) sum++;\\[\\begin{aligned}T(n) &amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\,\\sum_{r\\,=\\,0}^{i\\,-\\,1}\\,\\sum_{k\\,=\\,0}^{r\\cdot i\\,-\\,1}\\,1 \\\\\\\\&amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\,\\sum_{r\\,=\\,0}^{i\\,-\\,1}\\,r\\cdot i \\\\\\\\&amp; = \\sum_{i\\,=\\,0}^{n\\,-\\,1}\\, i\\cdot \\frac{i\\cdot(i-1)}{2} \\\\\\\\&amp; = \\mathcal{O}(n^4)\\end{aligned}\\]" }, { "title": "快速幂", "url": "/posts/binary-exponentiation/", "categories": "算法", "tags": "快速幂, 矩阵快速幂", "date": "2022-08-21 20:05:17 +0800", "snippet": "引言在计算指数如 $7^5$ 时，最朴素的做法就是逐个累乘，即：long long ans = 1;for (int i = 1; i &lt;= 5; i++) { ans *= 7;}显然算法的时间复杂度为 $\\mathcal{O}(n)$，效率虽然也是可以接受的，但显然其中有很多部分是属于重复操作的。例如我们计算出了 $7^2$，显然这个结果还可以继续使用，即$7^4=(7^2)^2$，从而计算 $7^5=(7^2)^2\\times7$。再举一个指数稍微大一点的例子，如 $7^8$，要计算 $7^8$，我们可以先计算出 $7^4$ 然后再平方；要计算 $7^4$，我们可以先计算 $7^2$，然后再平方；…，如此往复直到幂指数为 0，直接返回结果为 1。递归版从而可以总结出如下递归式：\\[\\textup{power}(a,n)=\\left\\{\\begin{matrix}1 &amp; (n=0)\\\\ \\textup{power}(a, \\lfloor n/2 \\rfloor)^2 &amp; (n&gt;0 \\textup{ and } n \\textup{ is even}) \\\\ \\textup{power}(a, \\lfloor n/2 \\rfloor)^2 \\times a &amp; (n&gt;0 \\textup{ and } n \\textup{ is odd})\\end{matrix}\\right.\\]上述过程实际就是在对指数进行二分，因此可知该算法的时间复杂度为 $\\mathcal{O}(\\log n)$long long power(int a, int n) { if (n == 0) { // 递归基 return 1; } // n &gt;&gt; 1，相当于 n / 2 long long tmp = power(a, n &gt;&gt; 1); // 二进制最后一位为1(即+1*2^0)，与1按位与得1 return (n &amp; 1) ? tmp * tmp * a : tmp * tmp;}非递归版我们将取幂的任务按照指数的 二进制表示 来分割成更小的任务。首先我们将 $n$ 表示为 2 进制，举一个例子：\\[3^{13} = 3^{(1101)_2} = 3^8 \\cdot 3^4 \\cdot 3^1\\]因为 $n$ 有 $\\lfloor \\log_2 n \\rfloor + 1$ 个二进制位，因此当我们知道了 $a^1, a^2, a^4, a^8, \\dots, a^{2^{\\lfloor \\log_2 n \\rfloor}}$ 后，我们只用计算 $\\Theta(\\log n)$ 次乘法就可以计算出 $a^n$。于是我们只需要知道一个快速的方法来计算上述 3 的 $2^k$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子：\\[\\begin{align}3^1 &amp;= 3 \\\\3^2 &amp;= \\left(3^1\\right)^2 = 3^2 = 9 \\\\3^4 &amp;= \\left(3^2\\right)^2 = 9^2 = 81 \\\\3^8 &amp;= \\left(3^4\\right)^2 = 81^2 = 6561\\end{align}\\]因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了：\\[3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323\\]将上述过程说得形式化一些，如果把 $n$ 写作二进制为 $(n_tn_{t-1}\\cdots n_1n_0)_2$，那么有：\\[n = n_t2^t + n_{t-1}2^{t-1} + n_{t-2}2^{t-2} + \\cdots + n_12^1 + n_02^0\\]其中 $n_i\\in{0,1}$。那么就有\\[\\begin{aligned}a^n &amp; = (a^{n_t 2^t + \\cdots + n_0 2^0})\\\\\\\\&amp; = a^{n_0 2^0} \\times a^{n_1 2^1}\\times \\cdots \\times a^{n_t2^t}\\end{aligned}\\]根据上式我们发现，原问题被我们转化成了形式相同的子问题的乘积，并且我们可以在常数时间内从 $2^i$ 项推出 $2^{i+1}$ 项。这个算法的复杂度是 $\\Theta(\\log n)$ 的，我们计算了 $\\Theta(\\log n)$ 个 $2^k$ 次幂的数，然后花费 $\\Theta(\\log n)$ 的时间选择二进制为 1 对应的幂来相乘。考虑到递归的开销较大，可以转化为以下非递归方式：简而言之，就是将指数 $n$，转化成二进制形式 $(n_tn_{t-1}\\cdots n_1n_0)_2$，从右到左依次编号为 0，1，…，t。对于其中任意第 k 位，若 $n_k=1$，则需要相乘 $a^{2^k}$。即抽离出公式：\\[\\begin{aligned}a^n &amp; = (a^{n_t 2^t + \\cdots + n_0 2^0})\\\\\\\\&amp; = a^{n_0 2^0} \\times a^{n_1 2^1}\\times \\cdots \\times a^{n_t2^t}\\end{aligned}\\]中 $n_k=1$ 的部分。long long power(int a, int n) { long long tmp = 1; while (n &gt; 0) { // 一共 log n 次 if (n &amp; 1) { // 当前位为 1 tmp *= a; } a = a * a; // 依次为 a^1, a^2, a^4, ..., a^(n/2) n &gt;&gt;= 1; // n 右移 } return tmp;}" }, { "title": "SQL一次通", "url": "/posts/sql-all-in-one/", "categories": "CTF", "tags": "SQL", "date": "2022-08-01 19:49:11 +0800", "snippet": "ManipulationColumn ConstraintsColumn constraints are the rules applied to the values of individual columns: PRIMARY KEY constraint can be used to uniquely identify the row. UNIQUE columns have a different value for every row. NOT NULL columns must have a value. DEFAULT assigns a default value for the column when no value is specified.There can be only one PRIMARY KEY column per table and multiple UNIQUE columns.CREATE TABLE student ( id INTEGER PRIMARY KEY, name TEXT UNIQUE, grade INTEGER NOT NULL, age INTEGER DEFAULT 10);CREATE TABLE StatementThe CREATE TABLE statement creates a new table in a database. It allows one to specify the name of the table and the name of each column in the table.CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype);INSERT StatementThe INSERT INTO statement is used to add a new record (row) to a table.It has two forms as shown: Insert into columns in order. Insert into columns by name.-- Insert into columns in order:INSERT INTO table_nameVALUES (value1, value2); -- Insert into columns by name:INSERT INTO table_name (column1, column2)VALUES (value1, value2);ALTER TABLE StatementThe ALTER TABLE statement is used to modify the columns of an existing table. When combined with the ADD COLUMN clause, it is used to add a new column.ALTER TABLE table_nameADD column_name datatype;DELETE StatementThe DELETE statement is used to delete records (rows) in a table. The WHERE clause specifies which record or records that should be deleted. If the WHERE clause is omitted, all records will be deleted.DELETE FROM table_nameWHERE some_column = some_value;UPDATE StatementThe UPDATE statement is used to edit records (rows) in a table. It includes a SET clause that indicates the column to edit and a WHERE clause for specifying the record(s).UPDATE table_nameSET column1 = value1, column2 = value2WHERE some_column = some_value;QueriesAND OperatorThe AND operator allows multiple conditions to be combined. Records must match both conditions that are joined by AND to be included in the result set. The given query will match any car that is blue and made after 2014.SELECT model FROM cars WHERE color = 'blue' AND year &gt; 2014;AS ClauseColumns or tables can be aliased using the AS clause. This allows columns or tables to be specifically renamed in the returned result set. The given query will return a result set with the column for name renamed to movie_title.SELECT name AS 'movie_title'FROM movies;OR OperatorThe OR operator allows multiple conditions to be combined. Records matching either condition joined by the OR are included in the result set. The given query will match customers whose state is either 'CA' or 'NY'.SELECT nameFROM customers WHERE state = 'CA' OR state = 'NY';% WildcardThe % wildcard can be used in a LIKE operator pattern to match zero or more unspecified character(s). The given query will match any movie that begins with The, followed by zero or more of any characters.SELECT nameFROM moviesWHERE name LIKE 'The%';SELECT StatementThe SELECT * statement returns all columns from the provided table in the result set. The given query will fetch all columns and records (rows) from the movies table.SELECT *FROM movies;_ WildcardThe _ wildcard can be used in a LIKE operator pattern to match any single unspecified character. The given query will match any movie which begins with a single character, followed by ove.SELECT nameFROM moviesWHERE name LIKE '_ove';ORDER BY ClauseThe ORDER BY clause can be used to sort the result set by a particular column either alphabetically or numerically. It can be ordered in two ways: DESC is a keyword used to sort the results in descending order. ASC is a keyword used to sort the results in ascending order (default).SELECT *FROM contactsORDER BY birth_date DESC;LIKE OperatorThe LIKE operator can be used inside of a WHERE clause to match a specified pattern. The given query will match any movie that begins with Star in its title.SELECT nameFROM moviesWHERE name LIKE 'Star%';DISTINCT ClauseUnique values of a column can be selected using a DISTINCT query. For a table contact_details having five rows in which the city column contains Chicago, Madison, Boston, Madison, and Denver, the given query would return: Chicago Madison Boston DenverSELECT DISTINCT cityFROM contact_details;BETWEEN OperatorThe BETWEEN operator can be used to filter by a range of values. The range of values can be text, numbers, or date data. The given query will match any movie made between the years 1980 and 1990, inclusive.SELECT *FROM moviesWHERE year BETWEEN 1980 AND 1990;LIMIT ClauseThe LIMIT clause is used to narrow, or limit, a result set to the specified number of rows. The given query will limit the result set to 5 rows.SELECT *FROM moviesLIMIT 5;NULL ValuesColumn values can be NULL, or have no value. These records can be matched (or not matched) using the IS NULL and IS NOT NULL operators in combination with the WHERE clause. The given query will match all addresses where the address has a value or is not NULL.SELECT addressFROM recordsWHERE address IS NOT NULL;WHERE ClauseThe WHERE clause is used to filter records (rows) that match a certain condition. The given query will select all records where the pub_year equals 2017.SELECT titleFROM libraryWHERE pub_year = 2017;Aggregate FunctionsColumn ReferencesThe GROUP BY and ORDER BY clauses can reference the selected columns by number in which they appear in the SELECT statement. The example query will count the number of movies per rating, and will: GROUP BY column 2 (rating) ORDER BY column 1 (total_movies)SELECT COUNT(*) AS 'total_movies', rating FROM movies GROUP BY 2 ORDER BY 1;SUM() Aggregate FunctionThe SUM() aggregate function takes the name of a column as an argument and returns the sum of all the value in that column.SELECT SUM(salary)FROM salary_disbursement;MAX() Aggregate FunctionThe MAX() aggregate function takes the name of a column as an argument and returns the largest value in a column. The given query will return the largest value from the amount column.SELECT MAX(amount) FROM transactions;COUNT() Aggregate FunctionThe COUNT() aggregate function returns the total number of rows that match the specified criteria. For instance, to find the total number of employees who have less than 5 years of experience, the given query can be used.Note: A column name of the table can also be used instead of *. Unlike COUNT(*), this variation COUNT(column) will not count NULL values in that column.SELECT COUNT(*)FROM employeesWHERE experience &lt; 5;GROUP BY ClauseThe GROUP BY clause will group records in a result set by identical values in one or more columns. It is often used in combination with aggregate functions to query information of similar records. The GROUP BY clause can come after FROM or WHERE but must come before any ORDER BY or LIMIT clause.The given query will count the number of movies per rating.SELECT rating, COUNT(*) FROM movies GROUP BY rating;MIN() Aggregate FunctionThe MIN() aggregate function returns the smallest value in a column. For instance, to find the smallest value of the amount column from the table named transactions, the given query can be used.SELECT MIN(amount) FROM transactions;AVG() Aggregate FunctionThe AVG() aggregate function returns the average value in a column. For instance, to find the average salary for the employees who have less than 5 years of experience, the given query can be used.SELECT AVG(salary)FROM employeesWHERE experience &lt; 5;HAVING ClauseThe HAVING clause is used to further filter the result set groups provided by the GROUP BY clause. HAVING is often used with aggregate functions to filter the result set groups based on an aggregate property. The given query will select only the records (rows) from only years where more than 5 movies were released per year.The HAVING clause must always come after a GROUP BY clause but must come before any ORDER BY or LIMIT clause.SELECT year, COUNT(*) FROM movies GROUP BY yearHAVING COUNT(*) &gt; 5;Aggregate FunctionsAggregate functions perform a calculation on a set of values and return a single value: COUNT() SUM() MAX() MIN() AVG()ROUND() FunctionThe ROUND() function will round a number value to a specified number of places. It takes two arguments: a number, and a number of decimal places. It can be combined with other aggregate functions, as shown in the given query. This query will calculate the average rating of movies from 2015, rounding to 2 decimal places.SELECT year, ROUND(AVG(rating), 2) FROM movies WHERE year = 2015;Multiple TablesOuter JoinAn outer join will combine rows from different tables even if the join condition is not met. In a LEFT JOIN, every row in the left table is returned in the result set, and if the join condition is not met, then NULL values are used to fill in the columns from the right table.SELECT column_name(s)FROM table1LEFT JOIN table2 ON table1.column_name = table2.column_name;WITH ClauseThe WITH clause stores the result of a query in a temporary table (temporary_movies) using an alias.Multiple temporary tables can be defined with one instance of the WITH keyword.WITH temporary_movies AS ( SELECT * FROM movies)SELECT *FROM temporary_moviesWHERE year BETWEEN 2000 AND 2020;UNION ClauseThe UNION clause is used to combine results that appear from multiple SELECT statements and filter duplicates.For example, given a first_names table with a column name containing rows of data “James” and “Hermione”, and a last_names table with a column name containing rows of data “James”, “Hermione” and “Cassidy”, the result of this query would contain three names: “Cassidy”, “James”, and “Hermione”.SELECT nameFROM first_namesUNIONSELECT nameFROM last_namesCROSS JOIN ClauseThe CROSS JOIN clause is used to combine each row from one table with each row from another in the result set. This JOIN is helpful for creating all possible combinations for the records (rows) in two tables.The given query will select the shirt_color and pants_color columns from the result set, which will contain all combinations of combining the rows in the shirts and pants tables. If there are 3 different shirt colors in the shirts table and 5 different pants colors in the pants table then the result set will contain 3 x 5 = 15 rows.SELECT shirts.shirt_color, pants.pants_colorFROM shirtsCROSS JOIN pants;Foreign KeyA foreign key is a reference in one table’s records to the primary key of another table. To maintain multiple records for a specific row, the use of foreign key plays a vital role. For instance, to track all the orders of a specific customer, the table order (illustrated at the bottom of the image) can contain a foreign key.Primary KeyA primary key column in a SQL table is used to uniquely identify each record in that table. A primary key cannot be NULL. In the example, customer_id is the primary key. The same value cannot re-occur in a primary key column. Primary keys are often used in JOIN operations.Inner JoinThe JOIN clause allows for the return of results from more than one table by joining them together with other results based on common column values specified using an ON clause. INNER JOIN is the default JOIN and it will only return results matching the condition specified by ON.SELECT * FROM booksJOIN authors ON books.author_id = authors.id;" }, { "title": "jQuery一次通", "url": "/posts/jquery-all-in-one/", "categories": "CTF", "tags": "jQuery", "date": "2022-08-01 19:45:56 +0800", "snippet": "IntroductionjQuery streamlines dynamic behaviorjQuery is a JavaScript library that streamlines the creation of dynamic behavior with predefined methods for selecting and manipulating DOM elements. It offers a simplified approach to implementing responsiveness and requires fewer lines of code to assign behaviors to DOM elements than traditional JavaScript methods.//Selecting DOM elements and adding an event listener in JSconst menu = document.getElementById('menu');const closeMenuButton = document.getElementById('close-menu-button');closeMenuButton.addEventListener('click', () =&gt; { menu.style.display = 'none';}); //Selecting DOM elements and adding an event listener in jQuery$('#close-menu-button').on('click', () =&gt;{ $('#menu').hide(); });jQuery document readyJavaScript code runs as soon as its file is loaded into the browser. If this happens before the DOM (Document Object Model) is fully loaded, unexpected issues or unpredictable behaviors can result.jQuery’s .ready() method waits until the DOM is fully rendered, at which point it invokes the specified callback function.$(document).ready(function() { // This code only runs after the DOM is loaded. alert('DOM fully loaded!');});jquery object variables start withjQuery objects are typically stored in variables where the variable name begins with a $ symbol. This naming convention makes it easier to identify which variables are jQuery objects as opposed to other JavaScript objects or values.//A variable representing a jQuery objectconst $myButton = $('#my-button');jQuery CDN ImportjQuery is typically imported from a CDN (Content Delivery Network) and added at the bottom of an HTML document in a &lt;script&gt; tag before the closing &lt;/body&gt; tag.The jQuery &lt;script&gt; tag must be listed before linking to any other JavaScript file that uses the jQuery library.&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!-- HTML code --&gt; &lt;!--The jQuery library--&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"&gt;&lt;/script&gt; &lt;!--Site-specific JavaScript code using jQuery--&gt; &lt;script src=\"script.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;Event Handlersjquery on event listenersjQuery .on() event listeners support all common browser event types such as mouse events, keyboard events, scroll events and more.// A mouse event 'click'$('#menu-button').on('click', () =&gt; { $('#menu').show();}); // A keyboard event 'keyup'$('#textbox').on('keyup', () =&gt; { $('#menu').show();}); // A scroll event 'scroll'$('#menu-button').on('scroll', () =&gt; { $('#menu').show();});jquery event objectIn a jQuery event listener, an event object is passed into the event handler callback when an event occurs. The event object has several important properties such as type (the event type) and currentTarget (the individual DOM element upon which the event occurred).// Hides the '#menu' element when it has been clicked.$('#menu').on('click', event =&gt; { // $(event.currentTarget) refers to the '#menu' element that was clicked. $(event.currentTarget).hide();});jquery event.currentTarget attributeIn a jQuery event listener callback, the event.currentTarget attribute only affects the individual element upon which the event was triggered, even if the listener is registered to a group of elements sharing a class or tag name.// Assuming there are several elements with the // class 'blue-button', 'event.currentTarget' will// refer to the individual element that was clicked.$('.blue-button').on('click', event =&gt; { $(event.currentTarget).hide();});jquery on method chainingjQuery .on() event listener methods can be chained together to add multiple events to the same element.// Two .on() methods for 'mouseenter' and // 'mouseleave' events chained onto the // '#menu-button' element. $('#menu-button').on('mouseenter', () =&gt; { $('#menu').show();}).on('mouseleave', () =&gt; { $('#menu').hide();});jquery on methodThe jQuery .on() method adds event listeners to jQuery objects and takes two arguments: a string declaring the event to listen for (such as ‘click’), and the event handler callback function. The .on() method creates an event listener that detects when an event happens (for example: when a user clicks a button), and then calls the event handler callback function, which will execute any defined actions after the event has happened.//The .on() method adds a 'click' event to the '#login' element. When the '#login' element is clicked, the callback function will be executed, which reveals the '#login-form' to the user. $('#login').on('click', () =&gt; { $('#login-form').show(); });Traversing the DOMjQuery childrenThe jQuery .children() method returns all child elements of a selected parent element.This method only applies to the direct children of the parent element, and not deeper descendents.In the example code, $('.parent').children() would select all the .item elements.&lt;div class=\"parent\"&gt; &lt;div class=\"item\"&gt;Child 1&lt;/div&gt; &lt;div class=\"item\"&gt;Child 2&lt;/div&gt; &lt;div class=\"item\"&gt;Child 3&lt;/div&gt;&lt;/div&gt;jQuery .parentThe jQuery .parent() method returns the parent element of a jQuery object.&lt;ul&gt;ul &lt;!-- this is the parent of li's one, two, six and ul three --&gt; &lt;li class=\"one\"&gt;li&lt;/li&gt; &lt;li class=\"two\"&gt;li&lt;/li&gt; &lt;ul class=\"three\"&gt; &lt;!-- this is the parent of li's four and five --&gt; &lt;li class=\"four\"&gt;li&lt;/li&gt; &lt;li class=\"five\"&gt;li&lt;/li&gt; &lt;/ul&gt; &lt;li class=\"six\"&gt;li&lt;/li&gt;&lt;/ul&gt;jQuery .nextThe jQuery .next() method targets the next element that shares the same parent element as the original element.In the following HTML code, the element returned by $('.two').next() would be &lt;li class=\"three\"&gt;Item three&lt;/li&gt;.&lt;ul&gt; &lt;li class=\"one\"&gt;Item one&lt;/li&gt; &lt;li class=\"two\"&gt;Item two&lt;/li&gt; &lt;li class=\"three\"&gt;Item three&lt;/li&gt;&lt;/ul&gt;jQuery .find()In jQuery, the .find() method will find and return all descendent elements that match the selector provided as an argument.This code block shows a snippet of HTML that has a simple shopping list. Using jQuery, the list items inside the shopping list can be selected. The listItems variable will be a jQuery object that contains the two list items from the shopping list./*In HTML:&lt;ul id='shopping-list'&gt; &lt;li class='list-item'&gt;Flour&lt;/li&gt; &lt;li class='list-item'&gt;Sugar&lt;/li&gt;&lt;/ul&gt;*/ // jQuery:const listItems = $('#shopping-list').find('.list-item');jQuery .siblingsThe jQuery .siblings() method targets all of the sibling elements of a particular element..siblings() can be used to add a selected class to an element on click and remove it from all of its sibling elements, ensuring that only one element appears as “selected” at one time.$('.choice').on('click', event =&gt; { // Remove the 'selected' class from any siblings $(event.currentTarget).siblings().removeClass('selected'); // Adds 'selected' class to that element only. $(event.currentTarget).addClass('selected');});jQuery .closestThe jQuery .closest() method travels up through the DOM tree to find the first (and closest) ancestor element matching a selector string." }, { "title": "CSS一次通", "url": "/posts/css-all-in-one/", "categories": "CTF", "tags": "CSS", "date": "2022-08-01 19:39:01 +0800", "snippet": "Snytax and Selectors&lt;link&gt; Link ElementThe &lt;link&gt; element is used to link HTML documents to external resources like CSS files. It commonly uses: href attribute to specify the URL to the external resource rel attribute to specify the relationship of the linked document to the current document type attribute to define the type of content being linked&lt;!-- How to link an external stylesheet with href, rel, and type attributes --&gt; &lt;link href=\"./path/to/stylesheet/style.css\" rel=\"stylesheet\" type=\"text/css\"&gt;Purpose of CSSCSS, or Cascading Style Sheets, is a language that is used in combination with HTML that customizes how HTML elements will appear. CSS can define styles and change the layout and design of a sheet.Write CSS in Separate FilesCSS code can be written in its own files to keep it separate from the HTML code. The extension for CSS files is .css. These can be linked to an HTML file using a &lt;link&gt; tag in the &lt;head&gt; section.&lt;head&gt; &lt;link href=\"style.css\" type=\"text/css\" rel=\"stylesheet\"&gt;&lt;/head&gt;Write CSS in HTML FileCSS code can be written in an HTML file by enclosing the code in &lt;style&gt; tags. Code surrounded by &lt;style&gt; tags will be interpreted as CSS syntax.&lt;head&gt; &lt;style&gt; h1 { color: blue; } &lt;/style&gt;&lt;/head&gt;Inline StylesCSS styles can be directly added to HTML elements by using the style attribute in the element’s opening tag. Each style declaration is ended with a semicolon. Styles added in this manner are known as inline styles.&lt;h2 style=\"text-align: center;\"&gt;Centered text&lt;/h2&gt; &lt;p style=\"color: blue; font-size: 18px;\"&gt;Blue, 18-point text&lt;/p&gt;Separating HTML code from CSS codeIt is common practice to separate content code in HTML files from styling code in CSS files. This can help make the code easier to maintain, by keeping the syntax for each file separate, and any changes to the content or styling can be made in their respective files.Class and ID SelectorsCSS classes can be reusable and applied to many elements. Class selectors are denoted with a period . followed by the class name. CSS ID selectors should be unique and used to style only a single element. ID selectors are denoted with a hash sign # followed by the id name./* Selects all elements with class=\"column\" */.column {} /* Selects element with id=\"first-item\" */#first-item {}Groups of CSS SelectorsMatch multiple selectors to the same CSS rule, using a comma-separated list. In this example, the text for both h1 and h2 is set to red.h1, h2 { color: red;}Selector ChainingCSS selectors define the set of elements to which a CSS rule set applies. For instance, to select all &lt;p&gt; elements, the p selector can be used to create style rules.Chaining SelectorsCSS selectors can be chained so that rule sets apply only to elements that match all criteria. For instance, to select &lt;h3&gt; elements that also have the section-heading class, the selector h3.section-heading can be used./* Select h3 elements with the section-heading class */h3.section-heading { color: blue;} /* Select elements with the section-heading and button class */.section-heading.button { cursor: pointer;}CSS Type SelectorsCSS type selectors are used to match all elements of a given type or tag name. Unlike for HTML syntax, we do not include the angle brackets when using type selectors for tag names. When using type selectors, elements are matched regardless of their nesting level in the HTML./* Selects all &lt;p&gt; tags */p {}CSS class selectorsThe CSS class selector matches elements based on the contents of their class attribute. For selecting elements having calendar-cell as the value of the class attribute, a . needs to be prepended..calendar-cell { color: #fff;}HTML attributes with multiple valuesSome HTML attributes can have multiple attribute values. Multiple attribute values are separated by a space between each attribute.&lt;div class=\"value1 value2 value3\"&gt;&lt;/div&gt;Selector SpecificitySpecificity is a ranking system that is used when there are multiple conflicting property values that point to the same element. When determining which rule to apply, the selector with the highest specificity wins out. The most specific selector type is the ID selector, followed by class selectors, followed by type selectors. In this example, only color: blue will be implemented as it has an ID selector whereas color: red has a type selector.h1#header { color: blue;} /* implemented */ h1 { color: red;} /* Not implemented */CSS ID selectorsThe CSS ID selector matches elements based on the contents of their id attribute. The values of id attribute should be unique in the entire DOM. For selecting the element having job-title as the value of the id attribute, a # needs to be prepended.#job-title { font-weight: bold;}CSS descendant selectorThe CSS descendant selector combinator is used to match elements that are descended from another matched selector. They are denoted by a single space between each selector and the descended selector. All matching elements are selected regardless of the nesting level in the HTML.div p { } section ol li { }Visual RulesCSS declarationsIn CSS, a declaration is the key-value pair of a CSS property and its value. CSS declarations are used to set style properties and construct rules to apply to individual or groups of elements. The property name and value are separated by a colon, and the entire declaration must be terminated by a semi-colon./* CSS declaration format:property-name: value;*/ /* CSS declarations */text-align: center;color: purple;width: 100px;Font SizeThe font-size CSS property is used to set text sizes. Font size values can be many different units or types such as pixels.font-size: 30px;Background ColorThe background-color CSS property controls the background color of elements.background-color: blue;!important RuleThe CSS !important rule is used on declarations to override any other declarations for a property and ignore selector specificity. !important rules will ensure that a specific declaration always applies to the matched elements. However, generally it is good to avoid using !important as bad practice.#column-one { width: 200px !important;} .post-title { color: blue !important;}OpacityThe opacity CSS property can be used to control the transparency of an element. The value of this property ranges from 0 (transparent) to 1 (opaque).opacity: 0.5;Font WeightThe font-weight CSS property can be used to set the weight (boldness) of text. The provided value can be a keyword such as bold or normal.font-weight: bold;Text AlignThe text-align CSS property can be used to set the text alignment of inline contents. This property can be set to these values: left, right, or center.text-align: right;CSS Rule SetsA CSS rule set contains one or more selectors and one or more declarations. The selector(s), which in this example is h1, points to an HTML element. The declaration(s), which in this example are color: blue and text-align: center style the element with a property and value. The rule set is the main building block of a CSS sheet.h1 { color: blue; text-align: center;}Setting foreground text color in CSSUsing the color property, foreground text color of an element can be set in CSS. The value can be a valid color name supported in CSS like green or blue. Also, 3 digit or 6 digit color code like #22f or #2a2aff can be used to set the color.p { color : #2a2aff ;} span { color : green ;}Resource URLsIn CSS, the url() function is used to wrap resource URLs. These can be applied to several properties such as the background-image.background-image: url(\"../resources/image.png\");Background ImageThe background-image CSS property sets the background image of an element. An image URL should be provided in the syntax url(\"moon.jpg\") as the value of the property.background-image: url(\"nyan-cat.gif\");Font FamilyThe font-family CSS property is used to specify the typeface in a rule set. Fonts must be available to the browser to display correctly, either on the computer or linked as a web font. If a font value is not available, browsers will display their default font. When using a multi-word font name, it is best practice to wrap them in quotes.h2 { font-family: Verdana;} #page-title { font-family: \"Courier New\";}Color Name KeywordsColor name keywords can be used to set color property values for elements in CSS.h1 { color: aqua;} li { color: khaki;}The Box ModelCSS Margin CollapseCSS margin collapse occurs when the top and bottom margins of blocks are combined into a single margin equal to the largest individual block margin.Margin collapse only occurs with vertical margins, not for horizontal margins./* The vertical margins will collapse to 30 pixelsinstead of adding to 50 pixels. */.block-one { margin: 20px;} .block-two { margin: 30px;}CSS auto keywordThe value auto can be used with the property margin to horizontally center an element within its container. The margin property will take the width of the element and will split the rest of the space equally between the left and right margins.div { margin: auto;}Dealing with overflowIf content is too large for its container, the CSS overflow property will determine how the browser handles the problem.By default, it will be set to visible and the content will take up extra space. It can also be set to hidden, or to scroll, which will make the overflowing content accessible via scroll bars within the original container.small-block { overflow: scroll;}Height and Width Maximums/MinimumsThe CSS min-width and min-height properties can be used to set a minimum width and minimum height of an element’s box. CSS max-width and max-height properties can be used to set maximum widths and heights for element boxes./* Any element with class \"column\" will be at most 200 pixels wide, despite the width property value of 500 pixels. */ .column { max-width: 200px; width: 500px;}The visibility PropertyThe CSS visibility property is used to render hidden objects invisible to the user, without removing them from the page. This ensures that the page structure and organization remain unchanged..invisible-elements { visibility: hidden;}The property box-sizing of CSS box modelThe CSS box model is a box that wraps around an HTML element and controls the design and layout. The property box-sizing controls which aspect of the box is determined by the height and width properties. The default value of this property is content-box, which renders the actual size of the element including the content box; but not the paddings and borders. The value border-box, on the other hand, renders the actual size of an element including the content box, paddings, and borders..container { box-sizing: border-box;}CSS box-sizing: border-boxThe value border-box of the box-sizing property for an element corresponds directly to the element’s total rendered size, including padding and border with the height and width properties.The default value of the border-box property is content-box. The value border-box is recommended when it is necessary to resize the padding and border but not just the content. For instance, the value border-box calculates an element’s height as follows: height = content height + padding + border.#box-example { box-sizing: border-box;}" }, { "title": "JavaScript一次通", "url": "/posts/javascript-all-in-one/", "categories": "CTF", "tags": "JavaScript", "date": "2022-08-01 19:21:33 +0800", "snippet": "Introductionconsole.log()The console.log() method is used to log or print messages to the console. It can also be used to print objects and other info.console.log('Hi there!');// Prints: Hi there!JavaScriptJavaScript is a programming language that powers the dynamic behavior on most websites. Alongside HTML and CSS, it is a core technology that makes the web run.MethodsMethods return information about an object, and are called by appending an instance with a period ., the method name, and parentheses.// Returns a number between 0 and 1Math.random();LibrariesLibraries contain methods that can be called by appending the library name with a period ., the method name, and a set of parentheses.Math.random();// ☝️ Math is the libraryNumbersNumbers are a primitive data type. They include the set of all integers and floating point numbers.let amount = 6;let price = 4.99;String .lengthThe .length property of a string returns the number of characters that make up the string.let message = 'good nite';console.log(message.length);// Prints: 9 console.log('howdy'.length);// Prints: 5Data InstancesWhen a new piece of data is introduced into a JavaScript program, the program keeps track of it in an instance of that data type. An instance is an individual case of a data type.BooleansBooleans are a primitive data type. They can be either true or false.let lateToWork = true;Math.random()The Math.random() function returns a floating-point, random number in the range from 0 (inclusive) up to but not including 1.console.log(Math.random());// Prints: 0 - 0.9Math.floor()The Math.floor() function returns the largest integer less than or equal to the given number.console.log(Math.floor(5.95)); // Prints: 5Single Line CommentsIn JavaScript, single-line comments are created with two consecutive forward slashes //.// This line will denote a commentNullNull is a primitive data type. It represents the intentional absence of value. In code, it is represented as null.let x = null;StringsStrings are a primitive data type. They are any grouping of characters (letters, spaces, numbers, or symbols) surrounded by single quotes ' or double quotes \".let single = 'Wheres my bandit hat?';let double = \"Wheres my bandit hat?\";Arithmetic OperatorsJavaScript supports arithmetic operators for: + addition - subtraction * multiplication / division % modulo// Addition5 + 5// Subtraction10 - 5// Multiplication5 * 10// Division10 / 5// Modulo10 % 5Multi-line CommentsIn JavaScript, multi-line comments are created by surrounding the lines with /* at the beginning and */ at the end. Comments are good ways for a variety of reasons like explaining a code block or indicating some hints, etc./* The below configuration must be changed before deployment. */ let baseUrl = 'localhost/taxwebapp/country';Remainder / Modulo OperatorThe remainder operator, sometimes called modulo, returns the number that remains after the right-hand number divides into the left-hand number as many times as it evenly can.// calculates # of weeks in a year, rounds down to nearest integerconst weeksInYear = Math.floor(365/7); // calcuates the number of days left over after 365 is divded by 7const daysLeftOver = 365 % 7 ; console.log(\"A year has \" + weeksInYear + \" weeks and \" + daysLeftOver + \" days\");Assignment OperatorsAn assignment operator assigns a value to its left operand based on the value of its right operand. Here are some of them: += addition assignment -= subtraction assignment *= multiplication assignment /= division assignmentlet number = 100; // Both statements will add 10number = number + 10;number += 10; console.log(number); // Prints: 120String InterpolationString interpolation is the process of evaluating string literals containing one or more placeholders (expressions, variables, etc).It can be performed using template literals: text ${expression} text.let age = 7; // String concatenation'Tommy is ' + age + ' years old.'; // String interpolation`Tommy is ${age} years old.`;VariablesVariables are used whenever there’s a need to store a piece of data. A variable contains data that can be used in the program elsewhere. Using variables also ensures code re-usability since it can be used to replace the same value in multiple places.const currency = '$';let userIncome = 85000; console.log(currency + userIncome + ' is more than the average income.');// Prints: $85000 is more than the average income.Undefinedundefined is a primitive JavaScript value that represents lack of defined value. Variables that are declared but not initialized to a value will have the value undefined.var a; console.log(a); // Prints: undefinedLearn Javascript: VariablesA variable is a container for data that is stored in computer memory. It is referenced by a descriptive name that a programmer can call to assign a specific value and retrieve it.// examples of variableslet name = \"Tammy\";const found = false;var age = 3;console.log(name, found, age);// Tammy, false, 3Declaring VariablesTo declare a variable in JavaScript, any of these three keywords can be used along with a variable name: var is used in pre-ES6 versions of JavaScript. let is the preferred way to declare a variable when it can be reassigned. const is the preferred way to declare a variable with a constant value.var age;let weight;const numberOfFingers = 20;Template LiteralsTemplate literals are strings that allow embedded expressions, ${expression}. While regular strings use single ' or double \" quotes, template literals use backticks instead.let name = \"Codecademy\";console.log(`Hello, ${name}`); // Prints: Hello, Codecademy console.log(`Billy is ${6+8} years old.`); // Prints: Billy is 14 years old.let Keywordlet creates a local variable in JavaScript &amp; can be re-assigned. Initialization during the declaration of a let variable is optional. A let variable will contain undefined if nothing is assigned to it.let count; console.log(count); // Prints: undefinedcount = 10;console.log(count); // Prints: 10const KeywordA constant variable can be declared using the keyword const. It must have an assignment. Any attempt of re-assigning a const variable will result in JavaScript runtime error.const numberOfColumns = 4;numberOfColumns = 8;// TypeError: Assignment to constant variable.String ConcatenationIn JavaScript, multiple strings can be concatenated together using the + operator. In the example, multiple strings and variables containing string values have been concatenated. After execution of the code block, the displayText variable will contain the concatenated string.let service = 'credit card';let month = 'May 30th'; let displayText = 'Your ' + service + ' bill is due on ' + month + '.'; console.log(displayText);// Prints: Your credit card bill is due on May 30th.ConditionalsControl FlowControl flow is the order in which statements are executed in a program. The default control flow is for statements to be read and executed in order from left-to-right, top-to-bottom in a program file.Control structures such as conditionals (if statements and the like) alter control flow by only executing blocks of code if certain conditions are met. These structures essentially allow a program to make decisions about which code is executed as the program runs.Logical Operator ||The logical OR operator || checks two values and returns a boolean. If one or both values are truthy, it returns true. If both values are falsy, it returns false. A B A || B false false false false true true true false true true true true true || false; // true10 &gt; 5 || 10 &gt; 20; // truefalse || false; // false10 &gt; 100 || 10 &gt; 20; // falseTernary OperatorThe ternary operator allows for a compact syntax in the case of binary (choosing between two choices) decisions. It accepts a condition followed by a ? operator, and then two expressions separated by a :. If the condition evaluates to truthy, the first expression is executed, otherwise, the second expression is executed.let price = 10.5;let day = \"Monday\"; day === \"Monday\" ? price -= 1.5 : price += 1.5;else StatementAn else block can be added to an if block or series of if-else if blocks. The else block will be executed only if the if condition fails.const isTaskCompleted = false; if (isTaskCompleted) { console.log('Task completed');} else { console.log('Task incomplete');}Logical Operator &amp;&amp;The logical AND operator &amp;&amp; checks two values and returns a boolean. If both values are truthy, then it returns true. If one, or both, of the values is falsy, then it returns false.true &amp;&amp; true; // true1 &gt; 2 &amp;&amp; 2 &gt; 1; // falsetrue &amp;&amp; false; // false4 === 4 &amp;&amp; 3 &gt; 1; // trueswitch StatementThe switch statements provide a means of checking an expression against multiple case clauses. If a case matches, the code inside that clause is executed.The case clause should finish with a break keyword. If no case matches but a default clause is included, the code inside default will be executed.Note: If break is omitted from the block of a case, the switch statement will continue to check against case values until a break is encountered or the flow is broken.const food = 'salad'; switch (food) { case 'oyster': console.log('The taste of the sea 🦪'); break; case 'pizza': console.log('A delicious pie 🍕'); break; default: console.log('Enjoy your meal');} // Prints: Enjoy your mealif StatementAn if statement accepts an expression with a set of parentheses: If the expression evaluates to a truthy value, then the code within its code body executes. If the expression evaluates to a falsy value, its code body will not execute.const isMailSent = true; if (isMailSent) { console.log('Mail sent to recipient');}Logical Operator !The logical NOT operator ! can be used to do one of the following: Invert a Boolean value. Invert the truthiness of non-Boolean values.let lateToWork = true;let oppositeValue = !lateToWork; console.log(oppositeValue); // Prints: falseComparison OperatorsComparison operators are used to comparing two values and return true or false depending on the validity of the comparison: === strict equal !== strict not equal &gt; greater than &gt;= greater than or equal &lt; less than &lt;= less than or equal1 &gt; 3 // false3 &gt; 1 // true250 &gt;= 250 // true1 === 1 // true1 === 2 // false1 === '1' // falseelse if ClauseAfter an initial if block, else if blocks can each check an additional condition. An optional else block can be added after the else if block(s) to run by default if none of the conditionals evaluated to truthy.const size = 10; if (size &gt; 100) { console.log('Big');} else if (size &gt; 20) { console.log('Medium');} else if (size &gt; 4) { console.log('Small');} else { console.log('Tiny');}// Print: SmallTruthy and FalsyIn JavaScript, values evaluate to true or false when evaluated as Booleans. Values that evaluate to true are known as truthy Values that evaluate to false are known as falsyFalsy values include false, 0, empty strings, null undefined, and NaN. All other values are truthy.FunctionsArrow Functions (ES6)Arrow function expressions were introduced in ES6. These expressions are clean and concise. The syntax for an arrow function expression does not require the function keyword and uses a fat arrow =&gt; to separate the parameter(s) from the body.There are several variations of arrow functions: Arrow functions with a single parameter do not require () around the parameter list. Arrow functions with a single expression can use the concise function body which returns the result of the expression without the return keyword.// Arrow function with two arguments const sum = (firstParam, secondParam) =&gt; { return firstParam + secondParam; }; console.log(sum(2,5)); // Prints: 7 // Arrow function with no arguments const printHello = () =&gt; { console.log('hello'); }; printHello(); // Prints: hello // Arrow functions with a single argument const checkWeight = weight =&gt; { console.log(`Baggage weight : ${weight} kilograms.`); }; checkWeight(25); // Prints: Baggage weight : 25 kilograms. // Concise arrow functionsconst multiply = (a, b) =&gt; a * b; console.log(multiply(2, 30)); // Prints: 60 FunctionsFunctions are one of the fundamental building blocks in JavaScript. A function is a reusable set of statements to perform a task or calculate a value. Functions can be passed one or more values and can return a value at the end of their execution. In order to use a function, you must define it somewhere in the scope where you wish to call it.The example code provided contains a function that takes in 2 values and returns the sum of those numbers.// Defining the function:function sum(num1, num2) { return num1 + num2;} // Calling the function:sum(3, 6); // 9Anonymous FunctionsAnonymous functions in JavaScript do not have a name property. They can be defined using the function keyword, or as an arrow function. See the code example for the difference between a named function and an anonymous function.// Named functionfunction rocketToMars() { return 'BOOM!';} // Anonymous functionconst rocketToMars = function() { return 'BOOM!';}Function ExpressionsFunction expressions create functions inside an expression instead of as a function declaration. They can be anonymous and/or assigned to a variable.const dog = function() { return 'Woof!';}Function ParametersInputs to functions are known as parameters when a function is declared or defined. Parameters are used as variables inside the function body. When the function is called, these parameters will have the value of whatever is passed in as arguments. It is possible to define a function without parameters.// The parameter is namefunction sayHello(name) { return `Hello, ${name}!`;}return KeywordFunctions return (pass back) values using the return keyword. return ends function execution and returns the specified value to the location where it was called. A common mistake is to forget the return keyword, in which case the function will return undefined by default.// With returnfunction sum(num1, num2) { return num1 + num2;} // Without return, so the function doesn't output the sumfunction sum(num1, num2) { num1 + num2;}Function DeclarationFunction declarations are used to create named functions. These functions can be called using their declared name. Function declarations are built from: The function keyword. The function name. An optional list of parameters separated by commas enclosed by a set of parentheses (). A function body enclosed in a set of curly braces {}.function add(num1, num2) { return num1 + num2;}Calling FunctionsFunctions can be called, or executed, elsewhere in code using parentheses following the function name. When a function is called, the code inside its function body runs. Arguments are values passed into a function when it is called.// Defining the functionfunction sum(num1, num2) { return num1 + num2;} // Calling the functionsum(2, 4); // 6ScopeScopeScope is a concept that refers to where values and functions can be accessed.Various scopes include: Global scope (a value/function in the global scope can be used anywhere in the entire program) File or module scope (the value/function can only be accessed from within the file) Function scope (only visible within the function), Code block scope (only visible within a { ... } codeblock)function myFunction() { var pizzaName = \"Volvo\"; // Code here can use pizzaName } // Code here can't use pizzaNameBlock Scoped Variablesconst and let are block scoped variables, meaning they are only accessible in their block or nested blocks. In the given code block, trying to print the statusMessage using the console.log() method will result in a ReferenceError. It is accessible only inside that if block.const isLoggedIn = true; if (isLoggedIn == true) { const statusMessage = 'User is logged in.';} console.log(statusMessage); // Uncaught ReferenceError: statusMessage is not definedGlobal VariablesJavaScript variables that are declared outside of blocks or functions can exist in the global scope, which means they are accessible throughout a program. Variables declared outside of smaller block or function scopes are accessible inside those smaller scopes.Note: It is best practice to keep global variables to a minimum.// Variable declared globallyconst color = 'blue'; function printColor() { console.log(color);} printColor(); // Prints: blueArraysProperty .lengthThe .length property of a JavaScript array indicates the number of elements the array contains.const numbers = [1, 2, 3, 4]; numbers.length // 4IndexArray elements are arranged by index values, starting at 0 as the first element index. Elements can be accessed by their index using the array name, and the index surrounded by square brackets.// Accessing an array elementconst myArray = [100, 200, 300]; console.log(myArray[0]); // 100console.log(myArray[1]); // 200console.log(myArray[2]); // 300Method .push()The .push() method of JavaScript arrays can be used to add one or more elements to the end of an array. .push() mutates the original array and returns the new length of the array.// Adding a single element:const cart = ['apple', 'orange'];cart.push('pear'); // Adding multiple elements:const numbers = [1, 2];numbers.push(3, 4, 5);Method .pop()The .pop() method removes the last element from an array and returns that element.const ingredients = ['eggs', 'flour', 'chocolate']; const poppedIngredient = ingredients.pop(); // 'chocolate'console.log(ingredients); // ['eggs', 'flour']MutableJavaScript arrays are mutable, meaning that the values they contain can be changed.Even if they are declared using const, the contents can be manipulated by reassigning internal values or using methods like .push() and .pop().const names = ['Alice', 'Bob']; names.push('Carl');// ['Alice', 'Bob', 'Carl']ArraysArrays are lists of ordered, stored data. They can hold items that are of any data type. Arrays are created by using square brackets, with individual elements separated by commas.// An array containing numbersconst numberArray = [0, 1, 2, 3]; // An array containing different data typesconst mixedArray = [1, 'chicken', false];LoopsWhile LoopThe while loop creates a loop that is executed as long as a specified condition evaluates to true. The loop will continue to run until the condition evaluates to false. The condition is specified before the loop, and usually, some variable is incremented or altered in the while loop body to determine when the loop should stop.while (condition) { // code block to be executed} let i = 0; while (i &lt; 5) { console.log(i); i++;}Reverse LoopA for loop can iterate “in reverse” by initializing the loop variable to the starting value, testing for when the variable hits the ending value, and decrementing (subtracting from) the loop variable at each iteration.const items = ['apricot', 'banana', 'cherry']; for (let i = items.length - 1; i &gt;= 0; i -= 1) { console.log(`${i}. ${items[i]}`);} // Prints: 2. cherry// Prints: 1. banana// Prints: 0. apricotDo…While StatementA do...while statement creates a loop that executes a block of code once, checks if a condition is true, and then repeats the loop as long as the condition is true. They are used when you want the code to always execute at least once. The loop ends when the condition evaluates to false.x = 0i = 0 do { x = x + i; console.log(x) i++;} while (i &lt; 5); // Prints: 0 1 3 6 10For LoopA for loop declares looping instructions, with three important pieces of information separated by semicolons ;: The initialization defines where to begin the loop by declaring (or referencing) the iterator variable The stopping condition determines when to stop looping (when the expression evaluates to false) The iteration statement updates the iterator each time the loop is completedfor (let i = 0; i &lt; 4; i += 1) { console.log(i);}; // Output: 0, 1, 2, 3Looping Through ArraysAn array’s length can be evaluated with the .length property. This is extremely helpful for looping through arrays, as the .length of the array can be used as the stopping condition in the loop.for (let i = 0; i &lt; array.length; i++){ console.log(array[i]);} // Output: Every item in the arrayBreak KeywordWithin a loop, the break keyword may be used to exit the loop immediately, continuing execution after the loop body.Here, the break keyword is used to exit the loop when i is greater than 5.for (let i = 0; i &lt; 99; i += 1) { if (i &gt; 5) { break; } console.log(i)} // Output: 0 1 2 3 4 5Nested For LoopA nested for loop is when a for loop runs inside another for loop.The inner loop will run all its iterations for each iteration of the outer loop.for (let outer = 0; outer &lt; 2; outer += 1) { for (let inner = 0; inner &lt; 3; inner += 1) { console.log(`${outer}-${inner}`); }} /* Output:0-00-10-21-01-11-2*/LoopsA loop is a programming tool that is used to repeat a set of instructions. Iterate is a generic term that means “to repeat” in the context of loops. A loop will continue to iterate until a specified condition, commonly known as a stopping condition, is met.IteratorsFunctions Assigned to VariablesIn JavaScript, functions are a data type just as strings, numbers, and arrays are data types. Therefore, functions can be assigned as values to variables, but are different from all other data types because they can be invoked.let plusFive = (number) =&gt; { return number + 5; };// f is assigned the value of plusFivelet f = plusFive; plusFive(3); // 8// Since f has a function value, it can be invoked. f(9); // 14 Callback FunctionsIn JavaScript, a callback function is a function that is passed into another function as an argument. This function can then be invoked during the execution of that higher order function (that it is an argument of).Since, in JavaScript, functions are objects, functions can be passed as arguments.const isEven = (n) =&gt; { return n % 2 == 0;} let printMsg = (evenFunc, num) =&gt; { const isNumEven = evenFunc(num); console.log(`The number ${num} is an even number: ${isNumEven}.`)} // Pass in isEven as the callback functionprintMsg(isEven, 4); // Prints: The number 4 is an even number: True.Higher-Order FunctionsIn Javascript, functions can be assigned to variables in the same way that strings or arrays can. They can be passed into other functions as parameters or returned from them as well.A “higher-order function” is a function that accepts functions as parameters and/or returns a function.JavaScript Functions: First-Class ObjectsJavaScript functions are first-class objects. Therefore: They have built-in properties and methods, such as the name property and the .toString() method. Properties and methods can be added to them. They can be passed as arguments and returned from other functions. They can be assigned to variables, array elements, and other objects.//Assign a function to a variable originalFuncconst originalFunc = (num) =&gt; { return num + 2 }; //Re-assign the function to a new variable newFuncconst newFunc = originalFunc; //Access the function's name propertynewFunc.name; //'originalFunc' //Return the function's body as a stringnewFunc.toString(); //'(num) =&gt; { return num + 2 }' //Add our own isMathFunction property to the functionnewFunc.isMathFunction = true; //Pass the function as an argumentconst functionNameLength = (func) =&gt; { return func.name.length }; functionNameLength(originalFunc); //12 //Return the functionconst returnFunc = () =&gt; { return newFunc };returnFunc(); //[Function: originalFunc]The .reduce() MethodThe .reduce() method iterates through an array and returns a single value.In the above code example, the .reduce() method will sum up all the elements of the array. It takes a callback function with two parameters (accumulator, currentValue) as arguments. On each iteration, accumulator is the value returned by the last iteration, and the currentValue is the current element. Optionally, a second argument can be passed which acts as the initial value of the accumulator.const arrayOfNumbers = [1, 2, 3, 4]; const sum = arrayOfNumbers.reduce((accumulator, currentValue) =&gt; { return accumulator + currentValue;}); console.log(sum); // 10The .forEach() MethodThe .forEach() method executes a callback function on each of the elements in an array in order.In the above example code, the callback function containing a console.log() method will be executed 5 times, once for each element.const numbers = [28, 77, 45, 99, 27]; numbers.forEach(number =&gt; { console.log(number);}); The .filter() MethodThe .filter() method executes a callback function on each element in an array. The callback function for each of the elements must return either true or false. The returned array is a new array with any elements for which the callback function returns true.In the above code example, the array filteredArray will contain all the elements of randomNumbers but 4.const randomNumbers = [4, 11, 42, 14, 39];const filteredArray = randomNumbers.filter(n =&gt; { return n &gt; 5;});The .map() MethodThe .map() method executes a callback function on each element in an array. It returns a new array made up of the return values from the callback function.The original array does not get altered, and the returned array may contain different elements than the original array.In the example code above, the .map() method is used to add ' joined the contest.' string at the end of each element in the finalParticipants array.const finalParticipants = ['Taylor', 'Donald', 'Don', 'Natasha', 'Bobby']; // add string after each final participantconst announcements = finalParticipants.map(member =&gt; { return member + ' joined the contest.';}) console.log(announcements);ObjectsRestrictions in Naming PropertiesJavaScript object key names must adhere to some restrictions to be valid. Key names must either be strings or valid identifier or variable names (i.e. special characters such as - are not allowed in key names that are not strings).// Example of invalid key namesconst trainSchedule = { platform num: 10, // Invalid because of the space between words. 40 - 10 + 2: 30, // Expressions cannot be keys. +compartment: 'C' // The use of a + sign is invalid unless it is enclosed in quotations.}Dot Notation for Accessing Object PropertiesProperties of a JavaScript object can be accessed using the dot notation in this manner: object.propertyName. Nested properties of an object can be accessed by chaining key names in the correct order.const apple = { color: 'Green', price: { bulk: '$3/kg', smallQty: '$4/kg' }};console.log(apple.color); // 'Green'console.log(apple.price.bulk); // '$3/kg'ObjectsAn object is a built-in data type for storing key-value pairs. Data inside objects are unordered, and the values can be of any type.Accessing non-existent JavaScript propertiesWhen trying to access a JavaScript object property that has not been defined yet, the value of undefined will be returned by default.const classElection = { date: 'January 12'}; console.log(classElection.place); // undefinedJavaScript Objects are MutableJavaScript objects are mutable, meaning their contents can be changed, even when they are declared as const. New properties can be added, and existing property values can be changed or deleted.It is the reference to the object, bound to the variable, that cannot be changed.const student = { name: 'Sheldon', score: 100, grade: 'A',} console.log(student)// { name: 'Sheldon', score: 100, grade: 'A' } delete student.scorestudent.grade = 'F'console.log(student)// { name: 'Sheldon', grade: 'F' } student = {}// TypeError: Assignment to constant variable.JavaScript for...in loopThe JavaScript for...in loop can be used to iterate over the keys of an object. In each iteration, one of the properties from the object is assigned to the variable of that loop.let mobile = { brand: 'Samsung', model: 'Galaxy Note 9'}; for (let key in mobile) { console.log(`${key}: ${mobile[key]}`);}Properties and values of a JavaScript objectA JavaScript object literal is enclosed with curly braces {}. Values are mapped to keys in the object with a colon (:), and the key-value pairs are separated by commas. All the keys are unique, but values are not.Key-value pairs of an object are also referred to as properties.const classOf2018 = { students: 38, year: 2018}Delete operatorOnce an object is created in JavaScript, it is possible to remove properties from the object using the delete operator. The delete keyword deletes both the value of the property and the property itself from the object. The delete operator only works on properties, not on variables or functions.const person = { firstName: \"Matilda\", age: 27, hobby: \"knitting\", goal: \"learning JavaScript\"}; delete person.hobby; // or delete person[hobby]; console.log(person);/*{ firstName: \"Matilda\" age: 27 goal: \"learning JavaScript\"}*/ javascript passing objects as argumentsWhen JavaScript objects are passed as arguments to functions or methods, they are passed by reference, not by value. This means that the object itself (not a copy) is accessible and mutable (can be changed) inside that function.const origNum = 8;const origObj = {color: 'blue'}; const changeItUp = (num, obj) =&gt; { num = 7; obj.color = 'red';}; changeItUp(origNum, origObj); // Will output 8 since integers are passed by value.console.log(origNum); // Will output 'red' since objects are passed // by reference and are therefore mutable.console.log(origObj.color);JavaScript Object MethodsJavaScript objects may have property values that are functions. These are referred to as object methods.Methods may be defined using anonymous arrow function expressions, or with shorthand method syntax.Object methods are invoked with the syntax: objectName.methodName(arguments).const engine = { // method shorthand, with one argument start(adverb) { console.log(`The engine starts up ${adverb}...`); }, // anonymous arrow function expression with no arguments sputter: () =&gt; { console.log('The engine sputters...'); },}; engine.start('noisily');engine.sputter(); /* Console output:The engine starts up noisily...The engine sputters...*/JavaScript destructuring assignment shorthand syntaxThe JavaScript destructuring assignment is a shorthand syntax that allows object properties to be extracted into specific variable values.It uses a pair of curly braces ({}) with property names on the left-hand side of an assignment to extract values from objects. The number of variables can be less than the total properties of an object.const rubiksCubeFacts = { possiblePermutations: '43,252,003,274,489,856,000', invented: '1974', largestCube: '17x17x17'};const {possiblePermutations, invented, largestCube} = rubiksCubeFacts;console.log(possiblePermutations); // '43,252,003,274,489,856,000'console.log(invented); // '1974'console.log(largestCube); // '17x17x17'shorthand property name syntax for object creationThe shorthand property name syntax in JavaScript allows creating objects without explicitly specifying the property names (ie. explicitly declaring the value after the key). In this process, an object is created where the property names of that object match variables which already exist in that context. Shorthand property names populate an object with a key matching the identifier and a value matching the identifier’s value.const activity = 'Surfing';const beach = { activity };console.log(beach); // { activity: 'Surfing' }this KeywordThe reserved keyword this refers to a method’s calling object, and it can be used to access properties belonging to that object.Here, using the this keyword inside the object function to refer to the cat object and access its name property.const cat = { name: 'Pipey', age: 8, whatName() { return this.name }}; console.log(cat.whatName()); // Output: Pipeyjavascript function thisEvery JavaScript function or method has a this context. For a function defined inside of an object, this will refer to that object itself. For a function defined outside of an object, this will refer to the global object (window in a browser, global in Node.js).const restaurant = { numCustomers: 45, seatCapacity: 100, availableSeats() { // this refers to the restaurant object // and it's used to access its properties return this.seatCapacity - this.numCustomers; }} JavaScript Arrow Function this ScopeJavaScript arrow functions do not have their own this context, but use the this of the surrounding lexical context. Thus, they are generally a poor choice for writing object methods.Consider the example code:loggerA is a property that uses arrow notation to define the function. Since data does not exist in the global context, accessing this.data returns undefined.loggerB uses method syntax. Since this refers to the enclosing object, the value of the data property is accessed as expected, returning \"abc\".const myObj = { data: 'abc', loggerA: () =&gt; { console.log(this.data); }, loggerB() { console.log(this.data); },}; myObj.loggerA(); // undefinedmyObj.loggerB(); // 'abc'getters and setters intercept property accessJavaScript getter and setter methods are helpful in part because they offer a way to intercept property access and assignment, and allow for additional actions to be performed before these changes go into effect.const myCat = { _name: 'Snickers', get name(){ return this._name }, set name(newName){ //Verify that newName is a non-empty string before setting as name property if (typeof newName === 'string' &amp;&amp; newName.length &gt; 0){ this._name = newName; } else { console.log(\"ERROR: name must be a non-empty string\"); } }}javascript factory functionsA JavaScript function that returns an object is known as a factory function. Factory functions often accept parameters in order to customize the returned object.// A factory function that accepts 'name', // 'age', and 'breed' parameters to return // a customized dog object. const dogFactory = (name, age, breed) =&gt; { return { name: name, age: age, breed: breed, bark() { console.log('Woof!'); } };}; javascript getters and setters restrictedJavaScript object properties are not private or protected. Since JavaScript objects are passed by reference, there is no way to fully prevent incorrect interactions with object properties.One way to implement more restricted interactions with object properties is to use getter and setter methods.Typically, the internal value is stored as a property with an identifier that matches the getter and setter method names, but begins with an underscore (_).const myCat = { _name: 'Dottie', get name() { return this._name; }, set name(newName) { this._name = newName; }}; // Reference invokes the getterconsole.log(myCat.name); // Assignment invokes the settermyCat.name = 'Yankee';" }, { "title": "HTML一次通", "url": "/posts/html-all-in-one/", "categories": "CTF", "tags": "HTML", "date": "2022-07-29 09:35:45 +0800", "snippet": "Elements and StructureHTMLHTML (HyperText Markup Language) is used to give content to a web page and instructs web browsers on how to structure that content.Element ContentThe content of an HTML element is the information between the opening and closing tags of an element.&lt;h1&gt;Codecademy is awesome! 🙂&lt;/h1&gt;&lt;li&gt; List Item ElementThe &lt;li&gt; list item element create list items inside: Ordered lists &lt;ol&gt; Unordered lists &lt;ul&gt;&lt;ol&gt; &lt;li&gt;Head east on Prince St&lt;/li&gt; &lt;li&gt;Turn left on Elizabeth&lt;/li&gt;&lt;/ol&gt; &lt;ul&gt; &lt;li&gt;Cookies&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;video&gt; Video ElementThe &lt;video&gt; element embeds a media player for video playback. The src attribute will contain the URL to the video. Adding the controls attribute will display video controls in the media player.Note: The content inside the opening and closing tag is shown as a fallback in browsers that don’t support the element.&lt;video src=\"test-video.mp4\" controls&gt; Video not supported&lt;/video&gt;&lt;em&gt; Emphasis ElementThe &lt;em&gt; emphasis element emphasizes text and browsers will usually italicize the emphasized text by default.&lt;p&gt;This &lt;em&gt;word&lt;/em&gt; will be emphasized in italics.&lt;/p&gt;&lt;ol&gt; Ordered List ElementThe &lt;ol&gt; ordered list element creates a list of items in sequential order. Each list item appears numbered by default.&lt;ol&gt; &lt;li&gt;Preheat oven to 325 F 👩‍🍳&lt;/li&gt; &lt;li&gt;Drop cookie dough 🍪&lt;/li&gt; &lt;li&gt;Bake for 15 min ⏰&lt;/li&gt;&lt;/ol&gt;&lt;div&gt; Div ElementThe &lt;div&gt; element is used as a container that divides an HTML document into sections and is short for “division”. &lt;div&gt; elements can contain flow content such as headings, paragraphs, links, images, etc.&lt;div&gt; &lt;h1&gt;A section of grouped elements&lt;/h1&gt; &lt;p&gt;Here’s some text for the section&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;h1&gt;Second section of grouped elements&lt;/h1&gt; &lt;p&gt;Here’s some text&lt;/p&gt;&lt;/div&gt;HTML StructureHTML is organized into a family tree structure. HTML elements can have parents, grandparents, siblings, children, grandchildren, etc.&lt;body&gt; &lt;div&gt; &lt;h1&gt;It's div's child and body's grandchild&lt;/h1&gt; &lt;h2&gt;It's h1's sibling&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;Closing TagAn HTML closing tag is used to denote the end of an HTML element. The syntax for a closing tag is a left angle bracket &lt; followed by a forward slash / then the element name and a right angle bracket to close &gt;.&lt;body&gt; ...&lt;/body&gt;Attribute Name and ValuesHTML attributes consist of a name and a value using the following syntax: name=\"value\" and can be added to the opening tag of an HTML element to configure or change the behavior of the element.&lt;elementName name=\"value\"&gt;&lt;/elementName&gt;&lt;br&gt; Line Break ElementThe &lt;br&gt; line break element will create a line break in text and is especially useful where a division of text is required, like in a postal address. The line break element requires only an opening tag and must not have a closing tag.A line break haiku.&lt;br&gt;Poems are a great use case.&lt;br&gt;Oh joy! A line break.&lt;img&gt; Image ElementHTML image &lt;img&gt; elements embed images in documents. The src attribute contains the image URL and is mandatory. &lt;img&gt; is an empty element meaning it should not have a closing tag.&lt;img src=\"image.png\"&gt;&lt;h1&gt;-&lt;h6&gt; Heading ElementsHTML can use six different levels of heading elements. The heading elements are ordered from the highest level &lt;h1&gt; to the lowest level &lt;h6&gt;.&lt;h1&gt;Breaking News&lt;/h1&gt;&lt;h2&gt;This is the 1st subheading&lt;/h2&gt;&lt;h3&gt;This is the 2nd subheading&lt;/h3&gt;...&lt;h6&gt;This is the 5th subheading&lt;/h6&gt;&lt;p&gt; Paragraph ElementThe &lt;p&gt; paragraph element contains and displays a block of text.&lt;p&gt;This is a block of text! Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;Unique ID AttributesIn HTML, specific and unique id attributes can be assigned to different elements in order to differentiate between them.When needed, the id value can be called upon by CSS and JavaScript to manipulate, format, and perform specific instructions on that element and that element only. Valid id attributes should begin with a letter and should only contain letters (a-Z), digits (0-9), hyphens (-), underscores (_), and periods (.).&lt;h1 id=\"A1\"&gt;Hello World&lt;/h1&gt;HTML AttributesHTML attributes are values added to the opening tag of an element to configure the element or change the element’s default behavior. In the provided example, we are giving the &lt;p&gt; (paragraph) element a unique identifier using the id attribute and changing the color of the default text using the style attribute.&lt;p id=\"my-paragraph\" style=\"color: green;\"&gt;Here’s some text for a paragraph that is being altered by HTML attributes&lt;/p&gt;&lt;ul&gt; Unordered List ElementThe &lt;ul&gt; unordered list element is used to create a list of items in no particular order. Each individual list item will have a bullet point by default.&lt;ul&gt; &lt;li&gt;Play more music 🎸&lt;/li&gt; &lt;li&gt;Read more books 📚&lt;/li&gt;&lt;/ul&gt;alt AttributeAn &lt;img&gt; element can have alternative text via the alt attribute. The alternative text will be displayed if an image fails to render due to an incorrect URL, if the image format is not supported by the browser, if the image is blocked from being displayed, or if the image has not been received from the URL.The text will be read aloud if screen reading software is used and helps support visually impaired users by providing a text descriptor for the image content on a webpage.&lt;img src=\"path/to/image\" alt=\"text describing image\" /&gt;&lt;body&gt; Body ElementThe &lt;body&gt; element represents the content of an HTML document. Content inside &lt;body&gt; tags are rendered on the web browsers.Note: There can be only one &lt;body&gt; element in a document.&lt;body&gt; &lt;h1&gt;Learn to code with Codecademy :)&lt;/h1&gt;&lt;/body&gt;&lt;span&gt; Span ElementThe &lt;span&gt; element is an inline container for text and can be used to group text for styling purposes. However, as &lt;span&gt; is a generic container to separate pieces of text from a larger body of text, its use should be avoided if a more semantic element is available.&lt;p&gt;&lt;span&gt;This text&lt;/span&gt; may be styled differently than the surrounding text.&lt;/p&gt;&lt;strong&gt; Strong ElementThe &lt;strong&gt; element highlights important, serious, or urgent text and browsers will normally render this highlighted text in bold by default.&lt;p&gt;This is &lt;strong&gt;important&lt;/strong&gt; text!&lt;/p&gt;HTML ElementAn HTML element is a piece of content in an HTML document and uses the following syntax: opening tag + content + closing tag. In the code provided: &lt;p&gt; is the opening tag. Hello World! is the content. &lt;/p&gt; is the closing tag.&lt;p&gt;Hello World!&lt;/p&gt;HTML TagThe syntax for a single HTML tag is an opening angle bracket &lt; followed by the element name and a closing angle bracket &gt;. Here is an example of an opening &lt;div&gt; tag.&lt;div&gt;&lt;a&gt; Anchor ElementThe &lt;a&gt; anchor element is used to create hyperlinks in an HTML document. The hyperlinks can point to other webpages, files on the same server, a location on the same page, or any other URL via the hyperlink reference attribute, href. The href determines the location the anchor element points to.&lt;!-- Creating text links --&gt;&lt;a href=\"http://www.codecademy.com\"&gt;Visit this site&lt;/a&gt; &lt;!-- Creating image links --&gt;&lt;a href=\"http://www.codecademy.com\"&gt; &lt;img src=\"logo.jpg\"&gt;Click this image&lt;/a&gt;&lt;head&gt; Head ElementThe &lt;head&gt; element contains general information about an HTML page that isn’t displayed on the page itself. This information is called metadata and includes things like the title of the HTML document and links to stylesheets.&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;!-- Metadata is contained in this element--&gt; &lt;/head&gt;&lt;/html&gt;&lt;target&gt; Target AttributeThe target attribute on an &lt;a&gt; anchor element specifies where a hyperlink should be opened. A target value of \"_blank\" will tell the browser to open the hyperlink in a new tab in modern browsers, or in a new window in older browsers or if the browser has had settings changed to open hyperlinks in a new window.&lt;a href=\"https://www.google.com\" target=\"_blank\"&gt;This anchor element links to google and will open in a new tab or window.&lt;/a&gt;IndentationHTML code should be formatted such that the indentation level of text increases once for each level of nesting.It is a common convention to use two or four space per level of nesting.&lt;div&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;Link to a Different Part of the Page #The anchor element &lt;a&gt; can create hyperlinks to different parts of the same HTML document using the href attribute to point to the desired location with # followed by the id of the element to link to.&lt;div&gt; &lt;p id=\"id-of-element-to-link-to\"&gt;A different part of the page!&lt;/p&gt;&lt;/div&gt; &lt;a href=\"#id-of-element-to-link-to\"&gt;Take me to a different part of the page&lt;/a&gt;&lt;html&gt; HTML ElementThe &lt;html&gt; element, the root of an HTML document, should be added after the !DOCTYPE declaration. All content/structure for an HTML document should be contained between the opening and closing &lt;html&gt; tags.&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;!-- I'm a comment --&gt;&lt;/html&gt;CommentsIn HTML, comments can be added between an opening &lt;!-- and closing --&gt;. Content inside of comments will not be rendered by browsers, and are usually used to describe a part of code or provide other details.Comments can span single or multiple lines.&lt;!-- Main site content --&gt;&lt;div&gt;Content&lt;/div&gt; &lt;!-- Comments can be multiple lines long.--&gt;WhitespaceWhitespace, such as line breaks, added to an HTML document between block-level elements will generally be ignored by the browser and are not added to increase spacing on the rendered HTML page. Rather, whitespace is added for organization and easier reading of the HTML document itself.&lt;p&gt;Test paragraph&lt;/p&gt; &lt;!-- The whitespace created by this line, and above/below this line is ignored by the browser--&gt; &lt;p&gt;Another test paragraph, this will sit right under the first paragraph, no extra space between.&lt;/p&gt;&lt;title&gt; Title ElementThe &lt;title&gt; element contains a text that defines the title of an HTML document. The title is displayed in the browser’s title bar or tab in which the HTML page is displayed. The &lt;title&gt; element can only be contained inside a document’s &lt;head&gt; element.&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Title of the HTML page&lt;/title&gt; &lt;/head&gt;&lt;/html&gt;File PathURL paths in HTML can be absolute paths, like a full URL, for example: https://developer.mozilla.org/en-US/docs/Learn or a relative file path that links to a local file in the same folder or on the same server, for example: ./style.css. Relative file paths begin with ./ followed by a path to the local file. ./ tells the browser to look for the file path from the current folder.&lt;a href=\"https://developer.mozilla.org/en-US/docs/Web\"&gt;The URL for this anchor element is an absolute file path.&lt;/a&gt; &lt;a href=\"./about.html\"&gt;The URL for this anchor element is a relative file path.&lt;/a&gt;Document Type DeclarationThe document type declaration &lt;!DOCTYPE html&gt; is required as the first line of an HTML document. The doctype declaration is an instruction to the browser about what type of document to expect and which version of HTML is being used, in this case it’s HTML5.&lt;!DOCTYPE html&gt;Tables&lt;tr&gt; Table Row ElementThe table row element, &lt;tr&gt;, is used to add rows to a table before adding table data and table headings.&lt;table&gt; &lt;tr&gt; ... &lt;/tr&gt;&lt;/table&gt;&lt;td&gt; Table Data ElementThe table data element, &lt;td&gt;, can be nested inside a table row element, &lt;tr&gt;, to add a cell of data to a table.&lt;table&gt; &lt;tr&gt; &lt;td&gt;cell one data&lt;/td&gt; &lt;td&gt;cell two data&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;thead&gt; Table Head ElementThe table head element, &lt;thead&gt;, defines the headings of table columns encapsulated in table rows.&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;heading 1&lt;/th&gt; &lt;th&gt;heading 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;rowspan AttributeSimilar to colspan, the rowspan attribute on a table header or table data element indicates how many rows that particular cell should span within the table. The rowspan value is set to 1 by default and will take any positive integer up to 65534.&lt;table&gt; &lt;tr&gt; &lt;th&gt;row 1:&lt;/th&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th rowspan=\"2\"&gt;row 2 (this row will span 2 rows):&lt;/th&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;row 3:&lt;/th&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;tbody&gt; Table Body ElementThe table body element, &lt;tbody&gt;, is a semantic element that will contain all table data other than table heading and table footer content. If used, &lt;tbody&gt; will contain all table row &lt;tr&gt; elements, and indicates that &lt;tr&gt; elements make up the body of the table. &lt;table&gt; cannot have both &lt;tbody&gt; and &lt;tr&gt; as direct children.&lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;row 1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;row 3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;th&gt; Table Heading ElementThe table heading element, &lt;th&gt;, is used to add titles to rows and columns of a table and must be enclosed in a table row element, &lt;tr&gt;.&lt;table&gt; &lt;tr&gt; &lt;th&gt;column one&lt;/th&gt; &lt;th&gt;column two&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;colspan AttributeThe colspan attribute on a table header &lt;th&gt; or table data &lt;td&gt; element indicates how many columns that particular cell should span within the table. The colspan value is set to 1 by default and will take any positive integer between 1 and 1000.&lt;table&gt; &lt;tr&gt; &lt;th&gt;row 1:&lt;/th&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;td&gt;col 3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;row 2:&lt;/th&gt; &lt;td colspan=\"2\"&gt;col 1 (will span 2 columns)&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;td&gt;col 3&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;tfoot&gt; Table Footer ElementThe table footer element, &lt;tfoot&gt;, uses table rows to give footer content or to summarize content at the end of a table.&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;heading 1&lt;/th&gt; &lt;th&gt;heading 2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;col 1&lt;/td&gt; &lt;td&gt;col 2&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;summary of col 1&lt;/td&gt; &lt;td&gt;summary of col 2&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;table&gt; Table ElementIn HTML, the &lt;table&gt; element has content that is used to represent a two-dimensional table made of rows and columns.&lt;table&gt; &lt;!-- rows and columns will go here --&gt;&lt;/table&gt;Forms&lt;input&gt;: Checkbox TypeWhen using an HTML input element, the type=\"checkbox\" attribute will render a single checkbox item. To create a group of checkboxes related to the same topic, they should all use the same name attribute. Since it’s a checkbox, multiple checkboxes can be selected for the same topic.&lt;input type=\"checkbox\" name=\"breakfast\" value=\"bacon\"&gt;Bacon 🥓&lt;br&gt;&lt;input type=\"checkbox\" name=\"breakfast\" value=\"eggs\"&gt;Eggs 🍳&lt;br&gt;&lt;input type=\"checkbox\" name=\"breakfast\" value=\"pancakes\"&gt;Pancakes 🥞&lt;br&gt;&lt;textarea&gt; ElementThe textarea element is used when creating a text-box for multi-line input (e.g. a comment section). The element supports the rows and cols attributes which determine the height and width, respectively, of the element.When rendered by the browser, textarea fields can be stretched/shrunk in size by the user, but the rows and cols attributes determine the initial size.Unlike the input element, the &lt;textarea&gt; element has both opening and closing tags. The value of the element is the content in between these tags (much like a &lt;p&gt; element). The code block shows a &lt;textarea&gt; of size 10x30 and with a name of \"comment\".&lt;textarea rows=\"10\" cols=\"30\" name=\"comment\"&gt;&lt;/textarea&gt;&lt;form&gt; ElementThe HTML &lt;form&gt; element is used to collect and send information to an external source.&lt;form&gt; can contain various input elements. When a user submits the form, information in these input elements is passed to the source which is named in the action attribute of the form.&lt;form method=\"post\" action=\"http://server1\"&gt; Enter your name: &lt;input type=\"text\" name=\"fname\"&gt; &lt;br/&gt; Enter your age: &lt;input type=\"text\" name=\"age\"&gt; &lt;br/&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt;&lt;input&gt;: Number TypeHTML input elements can be of type number. These input fields allow the user to enter only numbers and a few special characters inside the field.The example code block shows an input with a type of number and a name of balance. When the input field is a part of a form, the form will receive a key-value pair with the format: name: value after form submission.&lt;input type=\"number\" name=\"balance\" /&gt; &lt;input&gt; ElementThe HTML &lt;input&gt; element is used to render a variety of input fields on a webpage including text fields, checkboxes, buttons, etc. &lt;input&gt; element have a type attribute that determines how it gets rendered to a page.The example code block will create a text input field and a checkbox input field on a webpage.&lt;label for=\"fname\"&gt;First name:&lt;/label&gt;&lt;input type=\"text\" name=\"fname\" id=\"fname\"&gt;&lt;br&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt; I own a bike&lt;input&gt;: Range TypeA slider can be created by using the type=\"range\" attribute on an HTML input element. The range slider will act as a selector between a minimum and a maximum value. These values are set using the min and max attributes respectively. The slider can be adjusted to move in different steps or increments using the step attribute.The range slider is meant to act more as a visual widget to adjust between 2 values, where the relative position is important, but the precise value is not as important. An example of this can be adjusting the volume level of an application.&lt;input type=\"range\" name=\"movie-rating\" min=\"0\" max=\"10\" step=\"0.1\"&gt;&lt;select&gt; ElementThe HTML &lt;select&gt; element can be used to create a dropdown list. A list of choices for the dropdown list can be created using one or more &lt;option&gt; elements. By default, only one &lt;option&gt; can be selected at a time.The value of the selected &lt;select&gt;’s name and the &lt;option&gt;’ s value attribute are sent as a key-value pair when the form is submitted.&lt;select name=\"rental-option\"&gt; &lt;option value=\"small\"&gt;Small&lt;/option&gt; &lt;option value=\"family\"&gt;Family Sedan&lt;/option&gt; &lt;option value=\"lux\"&gt;Luxury&lt;/option&gt;&lt;/select&gt;Submitting a FormOnce we have collected information in a form we can send that information somewhere else by using the action and method attribute. The action attribute tells the form to send the information. A URL is assigned that determines the recipient of the information. The method attribute tells the form what to do with that information once it’s sent. An HTTP verb is assigned to the method attribute that determines the action to be performed.&lt;form action=\"/index3.html\" method=\"PUT\"&gt;&lt;/form&gt;&lt;input&gt;: Text TypeHTML &lt;input&gt; elements can support text input by setting the attribute type=\"text\". This renders a single row input field that users can type text inside.The value of the &lt;input&gt;‘s name and value attribute of the element are sent as a key-value pair when the form is submitted.&lt;input type=\"text\" name=\"username\"&gt;&lt;datalist&gt; ElementWhen using an HTML input, a basic search/autocomplete functionality can be achieved by pairing an &lt;input&gt; with a &lt;datalist&gt;. To pair a &lt;input&gt; with a &lt;datalist&gt; the &lt;input&gt;’s list value must match the value of the id of the &lt;datalist&gt;. The datalist element is used to store a list of &lt;option&gt;s.The list of data is shown as a dropdown on an input field when a user clicks on the input field. As the user starts typing, the list will be updated to show elements that best match what has been typed into the input field. The actual list items are specified as multiple option elements nested inside the datalist.datalists are ideal when providing users a list of pre-defined options, but to also allow them to write alternative inputs as well.&lt;input list=\"ide\"&gt; &lt;datalist id=\"ide\"&gt; &lt;option value=\"Visual Studio Code\" /&gt; &lt;option value=\"Atom\" /&gt; &lt;option value=\"Sublime Text\" /&gt;&lt;/datalist&gt;&lt;input&gt;: Radio Button TypeHTML &lt;input&gt; elements can be given a type=\"radio\" attribute that renders a single radio button. Multiple radio buttons of a related topic are given the same name attribute value. Only a single option can be chosen from a group of radio buttons.The value of the selected/checked &lt;input&gt;’s name and value attribute of this element are sent as a key-value pair when the form is submitted.&lt;input name=\"delivery_option\" type=\"radio\" value=\"pickup\" /&gt;&lt;input name=\"delivery_option\" type=\"radio\" value=\"delivery\" /&gt;Submittable InputHTML &lt;input&gt; elements can have a type attribute set to submit, by adding type=\"submit\". With this attribute included, a submit button will be rendered and, by default, will submit the &lt;form&gt; and execute its action.The text of a submit button is set to Submit by default but can also be changed by modifying the value attribute.&lt;input&gt; name AttributeIn order for a form to send data, it needs to be able to put it into key-value pairs. This is achieved by setting the name attribute of the input element. The name will become the key and the value of the input will become the value the form submits corresponding to the key.It’s important to remember that the name is not the same as the ID in terms of form submission. The ID and the name of the input may be the same, but the value will only be submitted if the name attribute is specified.In the code example, the first input will be submitted by the form, but the second one will not.&lt;input name=\"username\" id=\"username\" /&gt;&lt;input id=\"address\" /&gt;&lt;label&gt; ElementThe HTML &lt;label&gt; element provides identification for a specific &lt;input&gt; based on matching values of the &lt;input&gt;‘s id attribute and the &lt;label&gt;‘s for attribute. By default, clicking on the &lt;label&gt; will focus the field of the related &lt;input&gt;.The example code will create a text input field with the label text “Password: “ next to it. Clicking on “Password: “ on the page will focus the field for the related &lt;input&gt;.&lt;label for=\"password \"&gt;Password:&lt;/label&gt;&lt;input type=\"text\" id=\"password\" name=\"password\"&gt;&lt;input&gt; Password TypeThe HTML &lt;input&gt; element can have the attribute type=\"password\" that renders a single row input field which allows the user to type censored text inside the field. It is used to type in sensitive information.The value of this &lt;input&gt;’s name and value (actual value and not the censored version) attribute of this element are sent as a key-value pair when the form is submitted.The code block shows an example of the fields for a basic login form - the username and password fields.&lt;input type=\"text\" name=\"username\" /&gt;&lt;input type=\"password\" name=\"password\" /&gt;required AttributeIn HTML, input fields have an attribute called required which specifies that the field must include a value.The example code block shows an input field that is required. The attribute can be written as required=\"true\" or simply required.&lt;input type=\"password\" name=\"password\" required &gt;max AttributeHTML &lt;input&gt;s of type number have an attribute called max that specifies the maximum value for the input field.The code block shows an input number field that is set to have a maximum value of 20. Any value larger than 20 will mark the input field as having an error.&lt;input type=\"number\" max=\"20\"&gt;maxlength AttributeIn HTML, input fields with type text have an attribute called maxlength that specifies the maximum number of characters that can be entered into the field. The code block shows an input text field that accepts text that has a maximum length of 140 characters.&lt;input type=\"text\" name=\"tweet\" maxlength=\"140\"&gt;pattern AttributeIn a text input element, the pattern attribute uses a regular expression to match against (or validate) the value of the &lt;input&gt;, when the form is submitted.&lt;form action=\"/action_page.php\"&gt; Country code: &lt;input type=\"text\" name=\"country_code\" pattern=\"[A-Za-z]{3}\" title=\"Three letter country code\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;minlength AttributeIn HTML, an input field of type text has an attribute that supports minimum length validation. To check that the input text has a minimum length, add the minlength attribute with the character count.The example code block shows an example of a text field that has a minimum length of 6.&lt;input type=\"text\" name=\"username\" minlength=\"6\" /&gt;HTML Form ValidatorsHTML forms allow you to specify different kinds of validation for your input fields to make sure that data is entered correctly before being submitted. HTML supports a number of different validators, including things like minimum value, minimum/maximum length, etc. The validators are specified as attributes on the input field.min AttributeIn HTML, input fields with type number have an attribute called min that specifies the minimum value that can be entered into the field. The code block provided shows an input number field that accepts a number with minimum value 1.&lt;input type=\"number\" name=\"rating\" min=\"1\" max=\"10\"&gt;Semantic HTMLSemantic HTMLSemantic HTML introduces meaning to the code we write. Before Semantic HTML the elements didn’t have any meaning as to what it does or what content goes in it. An element such as &lt;div&gt; was used as a general-purpose element to create things from headers to footers to articles. With Semantic HTML we were introduced to elements that tell developers and browsers exactly what it does and what content should go in it.&lt;!--Non Semantic HTML--&gt;&lt;div id=\"footer\"&gt; &lt;p&gt;this is a footer&lt;/p&gt;&lt;/div&gt; &lt;!--Semantic HTML--&gt;&lt;footer&gt; &lt;p&gt;this is a footer&lt;/p&gt;&lt;/footer&gt;Element PlacementSemantic HTML introduces elements that can tell developers exactly what the element does or where it’s placed based on the name of that element. Some of these elements are &lt;header&gt;, &lt;nav&gt;, &lt;main&gt;, and &lt;footer&gt;. &lt;header&gt; describes the content at the top of the page &lt;body&gt;. It may include a logo, navigational links or a search bar. &lt;nav&gt; encapsulates the page’s navigational links. It is often placed inside the &lt;header&gt; or &lt;footer&gt;. &lt;main&gt; encapsulates the main content of a page between the header/navigation and the footer areas. &lt;footer&gt; includes the page’s footer content at the bottom of the &lt;body&gt;.Embedding mediaSemantic HTML introduces us to &lt;video&gt;, &lt;audio&gt; and &lt;embed&gt;. &lt;video&gt; allows us to add videos to our website. &lt;audio&gt; allows us to implement audio into our website. &lt;embed&gt; can be used to implement any type of media. These elements are universal in that they all use the src attribute to link the source of the content. &lt;video&gt; and &lt;audio&gt; requires a closing tag while &lt;embed&gt; is a self-closing tag.&lt;!--Video Tag--&gt;&lt;video src=\"4kvideo.mp4\"&gt;video not supported&lt;/video&gt; &lt;!--Audio Tag--&gt;&lt;audio src=\"koreanhiphop.mp3\"&gt;&lt;/audio&gt; &lt;!--Embed tag--&gt;&lt;embed src=\"babyyoda.gif\"/&gt;&lt;figure&gt; and &lt;figcaption&gt;The &lt;figure&gt; element is used to encapsulate media such as an image, diagram. or code snippet. The &lt;figcaption&gt; element is used to describe the media encapsulated within the &lt;figure&gt; element. Developers will normally use &lt;figcaption&gt; within the &lt;figure&gt; element to group the media and description. This way, if a developer decides to change the position of the media, the description will follow along with it.&lt;figure&gt; &lt;img src=\"qwerty.jpg\"&gt; &lt;figcaption&gt;The image shows the layout of a qwerty keyboard.&lt;/figcaption&gt;&lt;/figure&gt;&lt;section&gt; and &lt;article&gt;&lt;section&gt; defines elements in a document, such as chapters, headings, or any other area of the document with the same theme. &lt;article&gt; holds content that makes sense on its own such as articles, blogs, and comments. Generally developers will use &lt;section&gt; to define a theme for the webpage and use &lt;article&gt; to write independent content for that theme. This does not mean that &lt;article&gt; has to be used with &lt;section&gt;.&lt;section&gt; &lt;!--defines theme--&gt; &lt;h2&gt;Top Sports league in America&lt;/h2&gt;&lt;!--writes independent content relating to that theme--&gt; &lt;article&gt; &lt;p&gt;One of the top sports league is the nba.&lt;/p&gt; &lt;/article&gt;&lt;/section&gt;&lt;aside&gt; Aside ElementThe &lt;aside&gt; element is used to mark additional information that can enhance another element but isn’t required in order to understand the main content. Usually, this information would be in a sidebar or a location where it doesn’t obstruct the main piece of content. An example of this would be an article that discusses how to take care of a dog and next to the article an ad would appear advertising a dog grooming product.&lt;article&gt;&lt;!--Main Content--&gt;&lt;/article&gt;&lt;aside&gt;&lt;!--Additional information--&gt;&lt;/aside&gt;" }, { "title": "【转载】CTF web安全45天入门学习路线", "url": "/posts/ctf-web-schedule/", "categories": "CTF", "tags": "学习路线", "date": "2022-07-23 17:34:25 +0800", "snippet": "原文：https://www.apude.com/blog/9644.html前言因为最近在准备开发CTF学习平台，先做一个学习路线的整理，顺便也是对想学web的学弟学妹的一些建议。学习路线初期刚刚走进大学，入了web安全的坑，面对诸多漏洞必然是迷茫的，这时的首要任务就是打好网站开发的基础，曾有伟人说过-“自己不会做网站，何谈去找网站的漏洞”，在学习漏洞前，了解基本网站架构、基础网站开发原理，基础的前后端知识，能够让你之后的漏洞学习畅通无阻。html+css+js（2-3天）前端三要素 html、css、js是被浏览器解析的代码，是构成静态页面的基础。也是前端漏洞如xss、csrf的基础。重点了解html和js 推荐学习资料： https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求：能够写出简单表单，能够通过js获取DOM元素，控制DOM树即可。apache+php （4-5天）推荐使用phpstudy来进行傻瓜式安装，可以少走很多弯路。通过apache+php体会一下网站后端的工作，客户端浏览器通过请求apache服务器上的php脚本，php执行后生成的html页面返回给浏览器进行解析。重点了解php 推荐学习资料： https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求：了解基本网站原理，了解php基本语法，开发简单动态页面mysql （2-3天）之前已经安装的phpstudy可以轻易的安装mysql。mysql是一款典型的关系型数据库，一般来说，大部分网站都会带有数据库进行数据存储。重点了解sql语句 推荐学习资料： https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求： 能够用sql语句实现增删改查，并且能用php+mysql开发一个增删改查的管理系统（如学生管理系统）python (2-3天)虽然 “php是最好的语言”，但它主要还是应用在服务端做网站开发，我们搞安全经常需要写一些脚本或工具来进行诸如密码爆破、目录扫描、攻击自动化等操作，需要一个方便且趁手的编程语言，这里我推荐python重点学习requests、BeautifulSoup、re这三个库 推荐学习资料 https://www.runoob.com/ https://www.w3school.com.cn/ 能力要求： 了解python基础语法，能够用python爬取网站上的信息（requests+BeautifulSoup+re）burpsuite （1-2天）web安全的工具很多，但我觉得必备的渗透工具还得是它重点学习Proxy、Repeater、Intruder三个模块，分别用于抓包放包、重放包、爆破初步使用即可，在中期的漏洞学习中去逐渐熟练它 推荐学习资料 https://www.bilibili.com/video/BV1aq4y1X7oE DVWA之暴力破解 能力要求： 能够用burpsuite抓包改包、爆破用户名密码中期此时我们对网站已经不再陌生，能够自己动手完成一个简单站点。但我们写出来的代码真的安全吗？进入中期，我们便要开始着眼经典漏洞的学习。一个漏洞的学习，要搞明白三点（每学完一个漏洞就问自己这三个问题）： 如何利用这个漏洞进行恶意操作？ 为什么会产生这个漏洞？ 如何修复这个漏洞？SQL注入（7-8天）我们web狗学习的第一个漏洞一般都是SQL注入，它是web安全经典中的经典，也是在这里被灌输 “永远不信任用户的输入” 的口号，即使是现在sql注入也依旧存在，并且它还在不断衍生出如nosql注入、ORM注入等，可谓防不胜防。 推荐学习资料： sqli-labs 如何使用它网上有很多教学，wp也有很多大佬写了 这里贴一个https://blog.csdn.net/wang_624/article/details/101913584 sqlmap sql注入神器，有余力可以去看看它的源码，学习一下大佬进行sql注入并把它自动化的思路 buuctf 找相关的真题进行练习 wp百度一搜就有 [极客大挑战 2019]EasySQL [极客大挑战 2019]LoveSQL [SUCTF 2019]EasySQL 能力要求： 能够手工注入出任意表的数据，熟悉三种盲注的手法，能够通过sql注入实现任意文件读取和任意文件写入，能够自己编写一个不含sql注入的查询功能文件上传（7-8天）webshell是可以进行代码执行的木马而文件上传其实就是想办法把webshell上传到目标的服务器上去并成功解析，达到控制目标服务器的目的，这也是web安全的一个重点内容 推荐学习资料 upload-labs 几乎涵盖所有上传漏洞类型 buuctf 找相关的真题进行练习 [ACTF2020 新生赛]Upload 趁手的webshell管理工具： 蚁剑 能力要求： 会写php的webshell，明白webshell的原理，熟悉常见的文件上传绕过方法（如过后缀检测、过文件头检测、过MIME类型检测），能够自己编写一个不含漏洞的上传功能其他漏洞（14-15天）以上两个漏洞是我认为一个初学者最应该掌握也是最典型的漏洞，涵盖了代码执行、文件操作、数据库操作等web应用的主体内容。然而web安全的世界还有很多的漏洞需要你去探索，不过学会了这两种漏洞的你去学其他漏洞定然是游刃有余，不会像刚开始那么困惑了。以下四个为中期要掌握的漏洞 命令执行（RCE） php常见的代码执行（eval）、命令执行（system）函数 文件包含 file协议、php伪协议的利用 XSS 通过XSS获取用户cookie CSRF 通过csrf让用户点击恶意链接就触发敏感操作 后期此时的你熟悉了web安全几个核心的漏洞，并且有了一些ctf题目的练习经验，已经是一个合格的ctfer了。恭喜你。成功入门web安全。后续的学习方法或许该由你自己决定，我在此只给一些建议。多多参与CTF赛事参与当下举行的ctf赛事是最好的学习方法之一，即使是初学者也能够找到一些适合自己能力的赛事，比如极客大挑战、UNCTF、各个大学的新生赛等等都是不错的选择，在比赛中去发现自己知识的不足，然后去针对的补充这部分知识，是很好的学习循环，无需迷茫的去到处获取知识，而是在需要时去学习。Tips: 或许有人觉得直接刷题是一样的，但完全不是，当下比赛中的题往往更加前沿和流行，你可以找到当下的ctf题目趋势，紧跟技术热点，而且可以多多融入ctf竞技的氛围中，成长的更快。 ctfhub 可以很方便的查看最近举行的ctf赛事多多看其他师傅的博客打完ctf比赛的你肯定是想看writeup（答案）的，一般来说赛后过几天就会有很多师傅发出他的writeup，从比赛群、百度等途径都可以找到。多多看看其他师傅的解题思路，关注几个大牛，看看他们发的技术文章，都是很好的学习方法。总结web是个大坑，进去容易出去难，入门容易提升难，希望选择web的学弟学妹能够坚持在web安全这条路走下去，不要中途变了心。" }, { "title": "C++之运算符重载", "url": "/posts/cpp-operator-overloading/", "categories": "C++", "tags": "", "date": "2022-07-20 16:11:25 +0800", "snippet": "Operator OverloadingOperator overloading is an example of C++ polymorphism. C++ lets you extend operator overloading to user-defined types, permitting you, say, to use the + symbol to add two objects. Again, the compiler uses the number and type of operands to determine which definition of addition to use. Overloaded operators can often make code look more natural.This simple addition notation conceals the mechanics and emphasizes what is essential, and that is another goal of OOP.To overload an operator, you use a special function form called an operator function. An operator function has the following form, where op is the symbol for the operator being overloaded:operatorop(argument list)Overloading an operatorIn this section, say that we have a class named Point. As is named, a Point class is used to describe a point, which is defined as below:class Point { private: double x; double y; double length; public: Point(double new_x = 0.0, double new_y = 0.0); double GetX(); double GetY(); double GetLength(); void Modify(double const &amp;new_x, double const &amp;new_y); private: double CalcLength(double const &amp;xx, double const &amp;yy);};// definitionsdouble Point::CalcLength(double const &amp;xx, double const &amp;yy) { return sqrt(xx * xx + yy * yy);}Point::Point(double new_x, double new_y) : x(new_x), y(new_y), length(CalcLength(new_x, new_y)) {}double Point::GetX() { return x; }double Point::GetY() { return y; }double Point::GetLength() { return length; }void Point::Modify(double const &amp;new_x, double const &amp;new_y) { x = new_x; y = new_y; length = CalcLength(new_x, new_y);}Let’s overload +, -, *, ==, != to this class,#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class Point {private: double x; double y; double length; public: Point(double new_x = 0.0, double new_y = 0.0); double GetX(); double GetY(); double GetLength(); void Modify(double const &amp;new_x, double const &amp;new_y); Point operator+(Point const &amp;p) const; Point operator-(Point const &amp;p) const; Point operator*(double k) const; bool operator!=(Point const &amp;p) const; bool operator==(Point const &amp;p) const; private: double CalcLength(double const &amp;xx, double const &amp;yy);};double Point::CalcLength(double const &amp;xx, double const &amp;yy) { return sqrt(xx * xx + yy * yy);}Point::Point(double new_x, double new_y) : x(new_x), y(new_y), length(CalcLength(new_x, new_y)) {}double Point::GetX() { return x; }double Point::GetY() { return y; }double Point::GetLength() { return length; }void Point::Modify(double const &amp;new_x, double const &amp;new_y) { x = new_x; y = new_y; length = CalcLength(new_x, new_y);}Point Point::operator+(Point const &amp;t) const { Point sum(x + t.x, y + t.y); return sum;}Point Point::operator-(Point const &amp;t) const { Point ret(x - t.x, y - t.y); return ret;}Point Point::operator*(double k) const { Point p(x * k, y * k); return p;}bool Point::operator!=(Point const &amp;t) const { return (x != t.x) || (y != t.y);}bool Point::operator==(Point const &amp;t) const { return (x == t.x) &amp;&amp; (y == t.y);}The operation functions, like p1 + p2 (p1, p2are both objects of Point), are invoked by the 1st object (in this case p1), and take the 2nd object (in this case p2) as an argument. Therefore, it’s also OK to use syntax like:Point total = p1.operator+(p2);to invoke the operator + of Point class.It is also worth noticing that operator functions defined in a class always have ONLY one parameter. If you pursue efficiency, you should use const Point &amp;t or Point const &amp;t as parameters, because references are more efficient. Caution Don’t return a reference to a local variable or another temporary object. When the function terminates and the local variable or temporary object disappears, the reference becomes a reference to non-existent data.Overloading Restrictions The overloaded operator must have at least one operand that is a user-defined type. You can’t use an operator in a manner that violates the syntax rules for the original operator. Such as using b = *a. You can’t create new operator symbols. You cannot overload the following operators: Most of the operators can be overloaded by using either member or nonmember functions. However, you can use only member functions to overload the following operators:FriendsBy making a function a friend to a class, you allow the function the same access privileges that a member function of the class has.Conceptually, a = 3 * b; should be the same as a = b * 3;. However 3 is not a Point object, that is to say, 3 cannot invoke the operator * which we have defined inside the Point class.We can, however, take the statement a = 3 * b; as a = operator(double const &amp;k, Point const &amp;t); which is a nonmember function call. Since it’s a nonmember function, we don’t have access inside the Point class. Therefore, we need friend to offer us the access to the Point class.Inside the Point class declaration, we need to add this declaration:friend Point operator*(double k, Point const &amp;p);And outside the class, we need to define it, like this:Point operator*(double k, Point const &amp;p) { return p * k;}Pay attention to that there is NO friend in the definition. And since it’s not a member function of the Point class, you DO NOT have to add the scope specifier Point:: in the definition.With the nonmember overloaded operator function, the left operand of an operator expression corresponds to the first argument of the operator function, and the right operand corresponds to the second argument.Overloading the « OperatorThe ostream class overloads the operator &lt;&lt;, converting it into an output tool. Recall that cout is an ostream object and that it is smart enough to recognize all the basic C++ types.So one way to teach cout to recognize a Time object is to add a new function operator definition to the ostream class declaration. But it’s a dangerous idea to alter the iostream file and mess around with a standard interface. Instead, use the Time class declaration to teach the Time class how to use cout.The First VersionTo teach the Time class to use cout, you can use a friend function. Why? Because a statement like the following uses two objects, with the ostream class object (cout) first: cout &lt;&lt; trip;If you use a Time member function to overload &lt;&lt;, the Time object would come first, as it did when you overloaded the * operator with a member function. That means you would have to use the &lt;&lt; operator this way:trip &lt;&lt; cout; // if operator&lt;&lt;() were a Time member functionTherefore it is extremely reasonable to use a friend function to overload &lt;&lt;, like:void operator&lt;&lt;(ostream &amp;os, Point const &amp;p) { os &lt;&lt; \"(\" &lt;&lt; p.x &lt;&lt; \", \" &lt;&lt; p.y &lt;&lt; \")\";}The call cout &lt;&lt; trip should use the cout object itself, not a copy, so the function passes the object as a reference instead of by value. Thus, the expression cout &lt;&lt; trip causes os to be an alias for cout, and the expression cerr &lt;&lt; trip causes os to be an alias for cerr. The Time object can be passed by value or by reference because either form makes the object values available to the function. Again, passing by reference uses less memory and time than passing by value.The Second VersionBut the first implementation doesn’t allow you to combine the redefined « operator with the ones cout normally uses:cout &lt;&lt; \"Trip time: \" &lt;&lt; trip &lt;&lt; \" (Tuesday)\\n\"; // can't doYou can take the same approach with the friend function. You just revise the operator&lt;&lt;() function so that it returns a reference to an ostream object:ostream &amp;operator&lt;&lt;(ostream &amp;os, Point const &amp;p) { os &lt;&lt; \"(\" &lt;&lt; p.x &lt;&lt; \", \" &lt;&lt; p.y &lt;&lt; \")\"; return os;}Since you cannot overload functions that is only differed in return type, it’s highly recommended to use the second version to overload the operator &lt;&lt;, because it makes more sense than the first one." }, { "title": "C++之风格指南", "url": "/posts/cpp-style-guide/", "categories": "C++", "tags": "", "date": "2022-07-15 10:11:51 +0800", "snippet": "Why Care About Style?Style refers to the conventions that govern how we write code. A clean style keeps complex C++ code manageable and readable. To demonstrate the difference that style can make, look at the following two blocks of C++ code:This code follows a good style:#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; // This program prints out “Hello World!”int main() { string message = \"Hello World!\\n\"; cout &lt;&lt; message; return 0;}This code follows a bad style:using namespace std; #include &lt;iostream&gt;#include &lt;string&gt;string M= \"Hello World!\\n\";int main() { // Does some stuff cout &lt;&lt; M;; return (3);}Unlike syntax and semantics, style is very much a subjective matter. For the sake of consistency, we will follow Google’s C++ Style Guide in this article and throughout this course.Let’s learn some style tips that will take your C++ code to the next level!Include Statements#include statements give us access to functionalities from header file libraries. As a rule of thumb, include statements are mostly written at the beginning of any C++ program. Include headers should be listed in the following order: C system headers C++ standard library headers User-defined libraries’ headers.// C system headers#include &lt;stdlib.h&gt; // C++ standard library headers#include &lt;iostream&gt; // User-defined headers#include \"foo/server/bar.h\" // The rest of your code goes here…Naming ConventionsGenerally speaking, the best names are those that can be immediately understood by a new reader. Names should capture their context in the program without being too long.Regardless of the type, a name in C++ can never start with a digit. You should also avoid using the name of a predefined C++ keyword for your own variable or class.User-defined class names and function names use pascal case（帕斯卡拼写法）, which starts with a capital letter and has a capital letter for each new word, with no underscores. Examples: LinkedList or BubbleSort()Variable names are all lowercase, with underscores between words. Examples: student_id or resultPunctuation MarksBrackets {}: The open bracket should be on the same line as the statement. The closing bracket should be placed under the last line of code in the scope.Parentheses (): There should be no space between parentheses and the code inside. When parentheses are used in a statement, there should be a space before ( and a space after ). When parentheses are used as part of a class or function, only a space after ) is sufficient.Commas ,: There should always be a blank space after each comma.Let’s put them together in one example:int GetLargerNumber(int num_one, int num_two) { if (num_one &gt; num_two) { return num_one; } else { return num_two; }}FormattingSpacingTypes, variable, operators, and literal values should be separated by one space horizontally like so:string message = \"Hello World!\";Classes, functions, global variables declarations, and preprocessor directives (eg. #include) should be separated by one space vertically:#include &lt;iostream&gt; // preprocessor directive float pi = 3.1415; // global variable class MyClass { // class public: myClass() { }}; int main() { // function return 0;}IndentationAll indentations（缩进） should be two spaces at a time. There should be an indentation each time a new block (eg. loop, method, etc) is opened, as seen in the examples above. Do NOT use tabs in your code unless your editor is set to emit two spaces on tab.// Good: two spacesif (n == 3) { std:cout &lt;&lt; \"Fizz\";} // Bad: tab or four spacesif (n == 5) { std:cout &lt;&lt; \"Buzz\";}Line LengthEach line of text in your code should be at most 80 characters long. Programmers set up their work environment assuming a particular maximum window width, and 80 columns have been the traditional standard. You do not need to follow this rule as strictly as the others - just be mindful of lines that extend for too long.// This function name is too longReturnType LongClassName::ReallyReallyReallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3)" }, { "title": "C++之引用", "url": "/posts/cpp-references/", "categories": "C++", "tags": "", "date": "2022-07-14 19:17:51 +0800", "snippet": "ReferencesA reference（引用） variable is an alias（别名） for something else, that is, another name for an already existing variable.Suppose we have an int variable already called songqiao, we can create an alias to it by using the &amp; sign in the declaration:int &amp;sonny = songqiao;So here, we made sonny a reference to songqiao.Now when we make changes to sonny (add 1, subtract 2, etc), songqiao also changes.Two things to note about references: Anything we do to the reference also happens to the original. Aliases cannot be changed to alias something else.Pass-By-ReferencePreviously, when we passed parameters to a function, we used normal variables and that’s known as pass-by-value. But because the variables passed into the function are out of scope, we can’t actually modify the value of the arguments.Pass-by-reference（引用传参） refers to passing parameters to a function by using references. When called, the function can modify the value of the arguments by using the reference passed in.This allows us to: Modify the value of the function arguments. Avoid making copies of a variable/object for performance reasons.The following code shows an example of pass-by-reference. The reference parameters are initialized with the actual arguments when the function is called:void swap_num(int &amp;i, int &amp;j) { int temp = i; i = j; j = temp; } int main() { int a = 100; int b = 200; swap_num(a, b); std::cout &lt;&lt; \"A is \" &lt;&lt; a &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"B is \" &lt;&lt; b &lt;&lt; \"\\n\"; }Notice that the int &amp;i and int &amp;j are the parameters of the function swap_num().When swap_num() is called, the values of the variables a and b will be modified because they are passed by reference. The output will be:A is 200B is 100Suppose we didn’t pass-by-reference here and have the parameters as simply int i and int j in the swap_num() function, then i and j would swap, but a and b wouldn’t be modified.And the output will then be:A is 100B is 200To reiterate, using references as parameters allows us to modify the arguments’ values. This can be very useful in a lot cases.Pass-By-Reference with ConstFor example, in the following code, we are telling the compiler that the double variable pi will stay at 3.14 through out the program:double const pi = 3.14;If we try to change pi, the compiler will throw an error.Sometimes, we use const in a function parameter; this is when we know for a fact that we want to write a function where the parameter won’t change inside the function. Here’s an example:int triple(int const i) { return i * 3; }In this example, we are not modifying the i. If inside the function triple(), the value of i is changed, there will be a compiler error.So to save the computational cost for a function that doesn’t modify the parameter value(s), we can actually go a step further and use a const reference:int triple(int const &amp;i) { return i * 3; }This will ensure the same thing: the parameter won’t be changed. However, by making i a reference to the argument, this saves the computational cost of making a copy of the argument." }, { "title": "C++之循环新特性(C++11)", "url": "/posts/cpp-loop-in-cpp11/", "categories": "C++", "tags": "", "date": "2022-07-13 20:47:59 +0800", "snippet": "C++11 range-based for loopsSyntaxTo simplify, the basic syntax for range-based loop is for(range-declaration : range-expression), where:range-declaration : a declaration of a named variable, whose type is the type of the element of the sequence represented by range-expression, or a reference to that type. Often uses the auto specifier for automatic type deduction,range-expression : any expression that represents a suitable sequence (either an array or an object for which begin and end member functions or free functions are defined, see below) or a braced-init-list.For example,vector&lt;int&gt; v = {1, 2};for(int i : vec) { cout &lt;&lt; i;}In this loop, variable i take on the value of each element of v from the beginning to the end.If you are not sure which type you should use for range-declaration, you can simply use auto, like:string s = \"abc\";for(auto i : s) { cout &lt;&lt; i;}Worth noticing that the variable for range-declaration only receive the value of the element of the container, thus you cannot modify the elements of the container in the loop, unless you pass the reference like this:vector&lt;int&gt; vec;vec.push_back( 1 );vec.push_back( 2 ); for (int&amp; i : vec ) { i++; // increments the value in the vector}for (int i : vec ){ // show that the values are updated cout &lt;&lt; i &lt;&lt; endl;}In this case, the elements in vec are modified into {2, 3} respectively.for-each LoopsThe for-each loop is especially useful for iterating through list-like structures such as arrays or std::vector. Although regular for loops are perfectly capable of this task, for-each loops provides a more convenient syntax:int fibonacci[5] = {0, 1, 1, 2, 3};for (int number : fibonacci) { std::cout &lt;&lt; number;}The output of the above example is:01123This for-each loop iterates through an array called fibonacci using the counter variable number.The auto KeywordWhen iterating through an array using the for-each loop, the counter variable may be declared using the auto keyword.auto lets C++ deduce the type of the variable based on the type of the list it belongs to.Here is the previous example written using auto:int fibonacci[5] = {0, 1, 1, 2, 3};for (auto number : fibonacci) { std::cout &lt;&lt; number;}" }, { "title": "C++之类与对象", "url": "/posts/cpp-classes-and-objects/", "categories": "C++", "tags": "", "date": "2022-07-13 17:51:00 +0800", "snippet": "ClassThe class（类） serves as a blueprint for objects（对象）, which are instances（实例） of the class (just like age is an instance of int). An object gets characteristics and behaviors from its class.We can create an empty C++ class like this in a header file:class City { }; // &lt;-- notice this semicolon!Components of a class are called class members（成员）. Just like you can get a string’s length using .length(), you can access class members using the dot operator (object.class_member).There are two types of class members: Attributes（属性）, also known as member data（成员数据）, consist of information about an instance of the class. Methods（方法）, also known as member functions（成员函数）, are functions that you can use with an instance of the class. We use a . before method names to distinguish them from regular functions.We encapsulate（封装） — or enclose for simpler user access — attributes and methods in a class like this:class City { // attribute int population; // we'll explain 'public' laterpublic: // method void add_resident() { population++; } };Unless we have a mostly empty class, it’s common to split function declarations from definitions. We declare methods inside the class (in a header), then define the methods outside the class (in a .cpp file of the same name).How can we define methods outside a class? We can do this using ClassName:: before the method name to indicate its class like this:int City::get_population() { return population;}Unlike with regular functions, we need to include the header file in the .cpp file where we define the methods.ObjectsAn object is an instance of a class, which encapsulates data and functionality pertaining to that data.To create (or instantiate) an object, we can do this:City accra;We can give the object’s attributes values like this (note that these must be attributes you defined in the class and it should be in public):accra.population = 2270000;Later, we can access this information using the method we added to the City class (if it’s in a public part of the class):accra.get_population();Public, Private and ProtectedBy default, everything in a class is private, meaning class members are limited to the scope of the class. If you try to access a private class member, you’ll get an error:error: 'population' is a private member of 'City'But sometimes you need access to class members, and for that, there is public. You can use it to make everything below accessible outside the class:class City { int population; public: // stuff below is public void add_resident() { population++; } };There is also a private access modifier for when you want something below public to be private to the class:class City { int population; public: void add_resident() { population++; } private: // this stuff is private bool is_capital; };C++ provides a third access specifier: protected. It works much like private does, but allows inherited classes to access those class members.EncapsulationEncapsulation（封装） is an important concept in object-oriented programming. It means to hide sensitive details about an object’s implementation（实现） away from the user.In C++, encapsulation is achieved by declaring class members/attributes as private so they cannot be accessed from outside of the class.However, other parts of the program might need to read or modify the values of private class members. This is where accessor functions and mutator functions come in.Accessor FunctionsAn accessor function（存取函数） (also known as a “getter” function) is a public function that returns the value of a private member variable:class Clock {private: int time = 1200; public: // Accessor function for time int getTime() { return time; }}; int main() { Clock alarm; std::cout &lt;&lt; alarm.getTime(); // Output: 1200}The main() function calls the accessor function getTime() and gets the value of the time attribute even though it is private.Note: Accessor methods should always have a return type that matches the type of the member variable they’re accessing.Mutator FunctionsA mutator function（修改函数） (also known as a “setter” function) is a public function that sets the value of a private member variable:class Clock {private: int time = 1200; public: // Accessor function for time int getTime() { return time; } // Mutator function for time void setTime(int new_time) { time = new_time; }}; int main() { Clock alarm; alarm.setTime(930); std::cout &lt;&lt; alarm.getTime(); // Output: 930}Mutator functions usually have a return type of void. They are only responsible for resetting the value of an existing class member. As such, mutator functions often have one parameter of the same type as the attribute.ConstructorsA constructor（构造函数） is a special kind of method that lets you decide how the objects of a class get created. It has the same name as the class and no return type. Constructors really shine when you want to instantiate an object with specific attributes.Default ConstructorsA default constructor is a constructor that takes no parameters. If the object is created without specifying the initialization values, the default constructor will be called.In this example, the House class has a default constructor:class House {private: std::string location; int rooms; public: // Default constructor House() { location = \"New York\"; rooms = 5; } void summary() { std::cout &lt;&lt; location &lt;&lt; \" house with \" &lt;&lt; rooms &lt;&lt; \" rooms.\\n\"; }};This class has two private attributes that are initialized by the default House() constructor. The default constructor will be invoked when an object of the House class is created:int main() { House red_house; // Calls House() default constructor red_house.summary(); return 0;}The values of the location and rooms attributes will be set according to the code inside the default constructor. The program above produces the output:New York house with 5 rooms.A default constructor is great for ensuring that an object of the class is always initialized appropriately.Define Constructors Outside of ClassJust like methods, constructors can be defined outside of their class definition. Use the ClassName:: namespace to indicate that the constructor belongs to that class.For example, if the House() constructor was defined separately, it would look like this:House::House() { location = \"New York\"; rooms = 5;}This syntax applies to other types of constructors as well.Constructor with ParametersSimilar to functions, constructors can be declared with parameters. Constructors with parameters allow objects to be instantiated with specific values.Let’s add a constructor to the House class that takes two parameters:class House {private: std::string location; int rooms; public: // Default constructor House() { location = \"New York\"; rooms = 5; } // Constructor with parameters House(std::string loc, int num) { location = loc; rooms = num; } void summary() { std::cout &lt;&lt; location &lt;&lt; \" house with \" &lt;&lt; rooms &lt;&lt; \" rooms.\\n\"; }};To use this new constructor with parameters, create the object and provide the two required arguments:int main() { House green_house(\"Boston\", 3); // Calls House(std::string, int) constructor green_house.summary(); return 0;}This program will print:Boston house with 3 rooms.Note: Notice that there are two constructors inside the House class definition. There is no conflict between them because function overloading allows multiple constructors to co-exist in a class as long as each has a unique number and type of parameters.If we want to make sure each City is created with a name and a population, we can use parameters and a member initializer list to initialize attributes to values passed in:#include \"city.hpp\" class City { std::string name; int population; public: City(std::string new_name, int new_pop); };City::City(std::string new_name, int new_pop) // members get initialized to values passed in : name(new_name), population(new_pop) {}You could also write the definition like this:City::City(std::string new_name, int new_pop) { name = new_name; population = new_pop;}However, a member initialization list allows you to directly initialize each member when it gets created.To instantiate an object with attributes, you can do:City ankara(\"Ankara\", 5445000);Now we have a City called ankara with the following attributes: ankara.name set to \"Ankara\". ankara.population set to 5445000.Constructor Default ParametersThe parameters of a constructor can have default values. Defaulting the constructor parameters helps keep the number of constructors small.Using default parameters, the two constructors in the House class can be combined into one:class House {private: std::string location; int rooms; public: // Constructor with default parameters House(std::string loc = \"New York\", int num = 5) { location = loc; rooms = num; } void summary() { std::cout &lt;&lt; location &lt;&lt; \" house with \" &lt;&lt; rooms &lt;&lt; \" rooms.\\n\"; }};This constructor acts as both a default constructor and a constructor with parameters; it can accept one or two user-provided values or no values at all.int main() { House default_house; // Calls House(\"New York\", 5), default House texas_house(\"Texas\"); // Calls House(\"Texas\", 5) House big_florida_house(\"Florida\", 10); // Calls House(\"Florida\", 10)}Note: When calling a constructor with multiple default parameters, the compiler will match the arguments starting from the leftmost parameter. Therefore, a constructor call like this is not possible because it skips over the first parameter:House big_house(10); // Error: no constructor to handle House(int)To make this possible, a constructor that only takes one int parameter needs to be added to the class definition.Member Initializer ListsStrictly speaking, the constructor examples shown so far have been assigning（赋） value to attributes, not initiating（初始化） them. This subtle difference comes into play when dealing with const or reference variables, which must be initialized when they are declared. Using the regular assignment syntax for such types of attributes will not work:class Book {private: const std::string title; const int pages;public: Book() { title = \"Diary\"; // Error: const variables can't be assigned to pages = 100; // Error: const variables can't be assigned to };To solve this problem, C++ provides a way to initialize attributes via a member initializer list（成员初值列表）. It is placed after the constructor parameters list. The member initializer list begins with a colon :, and then lists each attribute and the initial value for that attribute. Each attribute in the list is separated by a comma.Let’s rewrite the Book() constructor using the member initializer list:class Book {private: const std::string title; const int pages;public: Book() : title(\"Diary\"), pages(100) {} // Member initializer list};This constructor will now work as intended because the member initializer list will properly initialize the const attributes instead of assign values to them.Note: Don’t forget to add the brackets {} after the member initializer list! Any code can still be placed into the constructor body.DestructorsA destructor（析构函数） is a special method that handles object destruction. Like a constructor, it has the same name as the class and no return type, but is preceded by a ~ operator and takes no parameters:class City { std::string name; int population; public: City(std::string new_name, int new_pop); ~City();}; // city.cppCity::~City() { // any final cleanup }City::~City() { // any final cleanup or simply nothing }Inside, you add any housekeeping that needs to happen before the object is destroyed. You generally won’t need to call a destructor; the destructor will be called automatically in any of the following scenarios: The object moves out of scope. The object is explicitly deleted. When the program ends.It is worth noticing that a destructor cannot manually be called (the compiler will automatically call it when it needs), and if you didn’t create a destructor, the compiler will create one itself.const Member FunctionsConsidering the following code:class Point {private: double x; double y;public: Point(double new_x = 0.0, double new_y = 0.0); void Show();}int main() { const Point a(1,1); a.Show(); return 0;}Point::Point(double new_x, double new_y) : x(new_x), y(new_y)) {}void Point::Show() const { cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \"\\ny: \" &lt;&lt; y &lt;&lt; \"\\nlength\" &lt;&lt; length;}With current C++, the compiler should object to a.Show();. Because the invoking object is const, however, the invoked function doesn’t offer any guarantee to not alter the object. We could solve this problem by passing a const reference as an argument. But there is no argument in this function. Thus we introduce a new syntax to solve such problems, a const function:void Show() const; // declarationvoid Point::Show() const { // definition }Just as you should use const references and pointers as formal function arguments whenever appropriate, you should make class methods const whenever they don’t modify the invoking object.The this PointerSuppose that we have a member function of the Point class to return an object who holds a larger length between two.It probably should have a prototype like this: (this is not a correct version!!!)Point Larger(const Point &amp;t) const;whose function return an object. However in this case, we use a const reference as an argument. Thus it should return a type that matches it. So the prototype should be altered to this:(this one is correct!!!)const Point &amp; Larger(const Point &amp;t) const;Now we are able to return a const reference of t (an object accessed explicitly because it is passed as an function argument), however we cannot return a reference of the invoking object, which is accessed implicitly.Therefore, there’s the this pointer, a pointer who points to the invoking object.With this, we are able to write the implementation:const Point &amp; Point::Larger(const Point &amp;t) const { if (t.length &gt; length) return t; return *this;}Basically, this is passed as a hidden argument to the method. Thus, the function call stock1.topval(stock2) sets this to the address of the stock1 object and makes that pointer available to the topval() method. Similarly, the function call stock2.topval(stock1) sets this to the address of the stock2 object. In general, all class methods have a this pointer set to the address of the object that invokes the method. Indeed, total_val in topval() is just shorthand notation for this-&gt;total_val. Note Each member function, including constructors and destructors, has a thispointer. The special property of the thispointer is that it points to the invoking object. If a method needs to refer to the invoking object as a whole, it can use the expression *this. Using the constqualifier after the function argument parentheses qualifies this as being a pointer to const; in that case, you can’t use this to change the object’s value.InheritanceIn C++, inheritance（继承） is the concept of defining a class in terms of another class. Inheritance makes it possible to reuse code and to establish hierarchical（等级制） relationships between classes.Basic InheritanceClasses that belong to an inheritance relationship are separated into two groups: Base class（基类） or parent class: The class being inherited from. Derived class（派生类） or child class: The class that inherits from the base class.A derived class inherits attributes and methods from its base class. To declare a derived class, place : after the class name and then write the access specifier and the name of the base class:#include &lt;iostream&gt; // Base classclass Animal {public: std::string gender; int age;}; // Derived classclass Dog: public Animal {public: std::string breed; void sound() { std::cout &lt;&lt; \"Woof\\n\"; }}; int main() { Dog buddy; buddy.gender = \"male\"; buddy.age = 8; buddy.breed = \"husky\"; buddy.sound(); // Outputs: Woof return 0;}In the example above, the Dog class inherits the attributes gender and age from the Animal class. The Dog class also has a new breed attribute and a new sound() function of its own.Constructor InheritanceFor the sake of simplicity, the class attributes in the previous example were kept as public. Normally, class attributes should be private because of encapsulation.A derived class also inherits the constructors of its base class. A derived class can initialize the private attributes of its base class by using the base class constructor in a member initializer list:#include &lt;iostream&gt; // Base classclass Animal {private: std::string gender; int age; public: Animal(std::string new_gender, int new_age) : gender(new_gender), age(new_age) {}}; // Derived classclass Dog: public Animal {private: std::string breed; public: // Call base class constructor Dog(std::string new_gender, int new_age, std::string new_breed) : Animal(new_gender, new_age), breed(new_breed) {} void sound() { std::cout &lt;&lt; \"Woof\\n\"; }}; int main() { // Calls Dog(string, int, string) constructor Dog buddy(\"male\", 8, \"Husky\"); // Output: Woof buddy.sound(); return 0;}Multilevel Inheritance（多层继承）A class can inherit from another class that is already derived from another class. This concept is sometimes referred to as an inheritance chain（继承链）:#include &lt;iostream&gt; class A { // A is the base classpublic: int a; A() { std::cout &lt;&lt; \"Constructing A\\n\"; }}; class B: public A { // class B inherits from class Apublic: int b; B() { std::cout &lt;&lt; \"Constructing B\\n\"; }}; class C: public B { // class C inherits from class Bpublic: int c; C() { std::cout &lt;&lt; \"Constructing C\\n\"; }}; int main() { C example; return 0;}In an inheritance chain, the “most base” class is always constructed first. The order of class construction then goes from the parent to the child. The output of the above program is:Constructing AConstructing BConstructing CIn an inheritance chain, a derived class inherits from all the base classes before it. Class C has all three attributes of a, b, and c because it is the last class in the inheritance chain.Types of InheritanceWhen declaring a derived class, the base class may be inherited through three different types of inheritance: Public Inheritance: The access specifiers of the base class members stay the same in the derived class. This is the most commonly used type of inheritance. Protected Inheritance: public and protected members of the base class become protected members of the derived class. Private Inheritance: All base class members become private members of the derived class.The following table is a reminder of the three access specifiers in C++: Access public protected private Inside the class yes yes yes Inside derived classes yes yes no Outside the class yes no no PolymorphismThe term polymorphism（多态） means “many forms”. In C++, polymorphism applies to class methods in an inheritance relationship.Polymorphism allows a derived class to override methods inherited from its base class. Although they have the same function signature, the C++ compiler will resolve function execution depending on the type of object that invokes the function.Take a look at the following example where two classes inherit from a common base class:#include &lt;iostream&gt; class Animal {public: void action() { std::cout &lt;&lt; \"The animal does something.\\n\"; }}; class Fish: public Animal {public: void action() { std::cout &lt;&lt; \"Fish swim.\\n\"; }}; class Bird: public Animal {public: void action() { std::cout &lt;&lt; \"Birds fly.\\n\"; }}; int main() { Animal newAnimal; Fish newFish; Bird newBird; newAnimal.action(); newFish.action(); newBird.action(); return 0;}The above program will produce the output:The animal does something.Fish swim.Birds fly.The two derived classes Fish and Bird both inherit the action() method from the base class Animal. However, each class has its own unique implementation of this method.In other words, the action() method has “polymorphed” into three different forms. The type of the caller object determines which form of action() is executed." }, { "title": "C++之vector", "url": "/posts/cpp-vector/", "categories": "C++", "tags": "", "date": "2022-07-12 19:20:37 +0800", "snippet": "vector 定义vector 是一个长度不定的数组，要使用它，首先要 include &lt;vector&gt;，然后按照 std::vector&lt;elementType&gt; name; 这样的形式进行定义，如：std::vector&lt;std::string&gt; students;。值得一提的是，可以通过 {} 来初始化 vector 的值，如：std::vector&lt;std::string&gt; students = {\"Charles\", \"Ann\"};Index 下标和数组一样，下标从 0 开始，可以通过 [index] 来访问下标为 index 的元素。.size()函数和 string 的 .length() 一样，可以使用 vector 的 .size() 来返回元素的数量。.push_back() &amp; .pop_back() 函数通过 .push_back(element) 来添加元素到末尾；通过 .pop_back() 来删除末尾元素。" }, { "title": "C++之函数", "url": "/posts/cpp-function/", "categories": "C++", "tags": "", "date": "2022-07-12 19:20:37 +0800", "snippet": "Function Declaration &amp; DefinitionA C++ function has two parts: Function declaration（函数声明） Function definition（函数定义）The declaration includes the function’s name, return type, and any parameters（参数）.The definition is the actual body of the function which executes when a function is called. The body of a function is typically enclosed in curly braces.#include &lt;iostream&gt; // function declarationvoid blah(); // main functionint main() { blah();} // function definitionvoid blah() { std::cout &lt;&lt; \"Blah blah\";}Function ArgumentsIn C++, the values passed to a function are known as arguments（实际参数）. They represent the actual input values.Function Declarations in Header fileC++ functions typically have two parts: declaration and definition.declarations -&gt; header files (.hpp or .h)definitions -&gt; .cpp file (with the same name as the header file where they are declared)#include &lt;iostream&gt;#include \"functions.hpp\" // don't forget! int main() { std::cout &lt;&lt; say_hi(\"Sabaa\"); }std::string say_hi(std::string name); // function declaration #include &lt;string&gt;#include \"functions.hpp\" std::string say_hi(std::string name) { // function defintion return \"Hey there, \" + name + \"!\\n\";}when compiling this 3 files in a bash, you need to tell g++ all of the files you need to compile by g++ main.cpp function.cpp or g++ main.cpp function.cpp -o test, then run the executable by ./a.out or ./test.Inline Functionsinline function （内联函数）is a function definition, usually in a header file, qualified by inline like this:inline void eat() { std::cout &lt;&lt; \"nom nom\\n\"; }Using inline advises the compiler to insert the function’s body where the function call is, which sometimes helps with execution speed (and sometimes hinders execution speed). Therefore, always use it after you have checked that it DOES IMPROVE the speed).inline functions are usually member functions, functions inside of classes. For example:void Cookie::eat() {std::cout &lt;&lt; \"nom nom\\n\";} // eat() belongs to the Cookie class:member functions are automatically inlined.ALWAYS add inline keyword when inlining functions that are not member functions in header files.Default ArgumentsDefault arguments are values assigned to parameters when the function is declared and defined:// Declarationvoid intro(std::string name, std::string lang = \"C++\"); // Definitionvoid intro(std::string name, std::string lang) { std::cout &lt;&lt; \"Hi, my name is \" &lt;&lt; name &lt;&lt; \" and I'm learning \" &lt;&lt; lang &lt;&lt; \".\\n\";}In example above, if we call the functions by intro(\"Bob\")(leaving the argument of lang blank), the function will run with the default value (lang = \"C++\"). However, it’ll also work if you add the argument for lang. In that case, the function will replace “C++” with the argument you added.ALWAYS put the default arguments in the last place.Function OverloadingIn a process known as function overloading（函数重载）, you can give multiple C++ functions the same name. Just make sure at least one of these conditions is true: Each has different type parameters. Each has a different number of parameters.Overloading enables you to change the way a function behaves depending on what is passed in as an argument:void print_cat_ears(char let) { std::cout &lt;&lt; \" \" &lt;&lt; let &lt;&lt; \" \" &lt;&lt; let &lt;&lt; \" \" &lt;&lt; \"\\n\"; std::cout &lt;&lt; let &lt;&lt; let &lt;&lt; let &lt;&lt; \" \" &lt;&lt; let &lt;&lt; let &lt;&lt; let &lt;&lt; \"\\n\";} void print_cat_ears(int num) { std::cout &lt;&lt; \" \" &lt;&lt; num &lt;&lt; \" \" &lt;&lt; num &lt;&lt; \" \" &lt;&lt; \"\\n\"; std::cout &lt;&lt; num &lt;&lt; num &lt;&lt; num &lt;&lt; \" \" &lt;&lt; num &lt;&lt; num &lt;&lt; num &lt;&lt; \"\\n\";}Function TemplatesThough overloading enables us to implement one functionality through the same name of functions that hold different types of parameters, it can be quite annoying to repeat the nearly same codes over and over again. Thanks to the templates, we can now use one functionality through one function name with different types of arguments.When building a template, unlike other functions, a template is completely declared and defined in a header file. And it looks like this:template &lt;typename T&gt;return_type some_function_name(T item1, T item2) { // do stuff with item1 and item2}For example we want to create a function that returns the maxium between two elements, we can build a template like this:template &lt;typename T&gt;T max(T a, T b) { return a&gt;b ? a:b;}As long as the type can be used with the methods expected, we can use the function with any type we want." }, { "title": "删除字符串的子串", "url": "/posts/delete-substr/", "categories": "", "tags": "字符串", "date": "2022-05-31 15:02:27 +0800", "snippet": "Description输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。Input输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。Output在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。输入样例：Sample InputTomcat is a male ccatatcatSample OutputTom is a male分析只需要一直搜索是否存在子串，直到不存在为止，存在的情况下，将s1中子串后的字符串拷贝到s1中子串出现的位置即可。注意使用strcat()进行拼接的时候要避免内存空间出现重叠以免出错。因此可以把后半段字符串拷贝到一个tmp数组中，再把tmp拼接在s1子串出现位置上。Code#include&lt;stdio.h&gt;#include&lt;string.h&gt;char s1[1001];char s2[1001];int main(){ gets(s1); gets(s2); char *p; // 用于接收strstr()传递的地址 while((p=strstr(s1,s2))!=NULL){ // 即存在子串 /* 由于strcat()不能将内存区域有重叠的字符串拼接 故需要将s1末尾的字符串拷贝到一个tmp数组中 */ char tmp[1001]; strcpy(tmp,p+strlen(s2)); // 在拼接s1和tmp前，需要改变s1字符串结束位置，即 *p='\\0'; strcat(s1,tmp); } puts(s1); return 0;}" }, { "title": "2019 计院 T3", "url": "/posts/j19-01/", "categories": "题解", "tags": "指针", "date": "2022-05-26 16:43:57 +0800", "snippet": "Description已知学生的记录由学号id（整数）和学习成绩score（浮点数）构成，在main函数中N名学生的 数据已存入a结构体数组中。请编写函数fun(STU stu[], STU *s)，函数的功能是：找出成绩最低 的学生记录，通过形参s返回主函数。#include&lt;cstdio&gt;using namespace std;//定义结构体STU//定义函数funvoid fun(STU stu[], STU *s){ }//以下是main函数int main(){ int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ scanf(\"%d%lf\",&amp;stu[i].id,&amp;stu[i].score); } // 预处理 // 调用 \tprintf(\"%d %f\",s-&gt;id,s-&gt;score);}分析首先由于 void fun(STU stu[], STU *s); 并没有说明数组长度的参数，因此我们需要在数组上做一些特殊的处理，用于判断数组是否到尾了。在这里根据常识学号都是正数，因此用学号 -1 来表示这个数组已经结束了，即 stu[n+1].id=-1。此外还需要定义一个指向 STU 的指针 s，用于接收分数最小的学生的信息。注意一定要初始化这个指针，可以指向一个新定义的结构体变量 tmp，或者是 stu[0]（如果从 stu[1] 开始储存学生信息的话）。（虽然实际上，直接用 &amp;tmp 接收值就可以了，但是题目是这么要求的，只能硬着头皮这么写了）Code#include&lt;cstdio&gt;using namespace std;//定义结构体STUstruct STU{ int id; double score;}stu[1001];//定义函数funvoid fun(STU stu[], STU *s){ // 指针s用于传递 double min=stu-&gt;score; // 先认为第一个数组为最小值 while(stu-&gt;id!=-1){ if(stu-&gt;score&lt;min){ min=stu-&gt;score; *s=*stu; // 通过指针s传递最小值元素 } stu++; }}//以下是main函数int main(){ int n; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++){ scanf(\"%d%lf\",&amp;stu[i].id,&amp;stu[i].score); } // 预处理 stu[n+1].id=-1; // -1 为终止标记 STU tmp; STU *s=&amp;tmp; // 接收所求的结构体 // 调用 fun(stu+1,s);\tprintf(\"%d %f\",s-&gt;id,s-&gt;score); return 0;}/*523 54.34547 453.147854 4.54784 -0.45543 0.0*/" }, { "title": "L1-050 倒数第N个字符串", "url": "/posts/L1050/", "categories": "题解, PAT", "tags": "进制", "date": "2022-05-24 19:27:47 +0800", "snippet": "L1-050 倒数第N个字符串 Description给定一个完全由小写英文字母组成的字符串等差递增序列，该序列中的每个字符串的长度固定为 L，从 L 个 a 开始，以 1 为步长递增。例如当 L 为 3 时，序列为 { aaa, aab, aac, …, aaz, aba, abb, …, abz, …, zzz }。这个序列的倒数第27个字符串就是 zyz。对于任意给定的 L，本题要求你给出对应序列倒数第 N 个字符串。Input输入在一行中给出两个正整数 L（2 ≤ L ≤ 6）和 N（$≤10^5$）。Output在一行中输出对应序列倒数第 N 个字符串。题目保证这个字符串是存在的。输入样例：Sample Input3 7417Sample Outputpat分析思路1本质上是一个 26 进制的转化加减法问题，通过减法过程即可。用一个数组 digit[]，来储存 26 进制数，其中 digit[0] （范围为 $[0,25]$）用于储存个位，digit[1] 用于储存十位，以此类推，那么这个 26 进制数 $N$ 就可以表示为：\\[(N)_{26}=\\mathrm{digit}[0] \\cdot26^0+\\mathrm{digit}[1] \\cdot26^1+...+\\mathrm{digit}[n] \\cdot26^n\\]这里使用的是最简单的模拟方式，逐个减 1。当 $\\mathrm {digit}[i]=-1$ 时，则说明需要退位，具体来讲就是 $\\mathrm {digit}[i]=25$，$\\mathrm {digit}[i+1]–$ ，若 $\\mathrm {digit}[i+1]=-1$ ，那么继续退位，如此循环。由于题目明确指出所要找的数是存在的，因此不需要担心出现负数的情况。思路2先全部转化成 10 进制，然后做减法，得到的结果在转化成 26 进制。对于一个 l 位的 26 进制数，它的所有数字的个数为：\\[\\begin{matrix} \\underbrace{ 26\\times26\\times...\\times26 } =26^l\\\\ l个26\\qquad \\end{matrix}\\]那么我们用 n 去减去这个数字，就得到了倒数第 n 个数字的十进制数，只需要把他转化成 26 进制即可。Code思路1#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int digit[7];// digit[0] 代表个位，以此类推void minus(int dig){ digit[dig]--; if(digit[dig]==-1){ // 需要退位 digit[dig]=25; minus(dig+1); // 退位 }}int main(){ int l,n; scanf(\"%d%d\",&amp;l,&amp;n); for(int i=0;i&lt;l;i++){ //从最大数倒着数 digit[i]=25; } for(int i=1;i&lt;n;i++){ minus(0); } for(int i=l-1;i&gt;=0;i--){ printf(\"%c\",digit[i]+'a'); } return 0;}思路2#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std;int digit[7];int main(){ int l,n; scanf(\"%d%d\",&amp;l,&amp;n); int tot=pow(26,l); int num=tot-n; int p=0; while(l--){ digit[p++]=num%26; num/=26; } for(int i=p-1;i&gt;=0;i--){ printf(\"%c\",digit[i]+'a'); } return 0;}" }, { "title": "存储类型", "url": "/posts/storage-class/", "categories": "", "tags": "", "date": "2022-05-22 14:58:57 +0800", "snippet": "存储类型auto 型局部变量可以声明为 auto 型（实际上可以省略）对于 auto 型变量，在调用函数时，会为他们分配空间，函数调用结束时，空间被释放。int fun(){ auto int a; // auto 可省略 ... return a;}例如这道题，函数内部 m,n 均为 auto 型，每次调用都是重新开辟空间，上一次的修改并不会保存，因此选 B。static 型static 型局部变量存储在静态存储区，整个程序运行期间均占有内存，只有在程序结束时才会释放内存。也就是说，第一次调用函数对他做出的改变，在第二次调用时并不会改变。例如：主函数中一共调用 3 次 Function() ，由于 Function() 内部 n 为 static 型，因此前一次调用的改变是保留的，也就是说：i=1 时，调用 Function() ，在 Function() 内 n 变为 2；i=2 时，调用 Function() ，在 Function() 内 n 变为 2+1=3；i=3 时，调用 Function() ，在 Function() 内 n 变为 3+1=4；故这道题选 A。又例如这道题我们不妨利用这个程序来帮助理解：#include&lt;cstdio&gt;using namespace std;int f(int a,int b){ static int m=1; printf(\"进入f后 内部最开始m=%d\\n\",m); m=m+2*a+b; printf(\"进入f后 m的值变为m=%d\\n\",m); return m;}int main(){ int k=2,m=3,p; printf(\"在主函数里 m=%d\\n第一次\",m); p=f(k,m); printf(\"第一次调用 f 后 p=%d\\n\",p); printf(\"第一次调用 f 后 主函数里 m=%d\\n第二次\",m); p=f(k,m); printf(\"第二次调用 f 后 p=%d\\n\",p); return 0;}输出结果：在主函数里 m=3第一次进入f后 内部最开始m=1进入f后 m的值变为m=8第一次调用 f 后 p=8第一次调用 f 后 主函数里 m=3第二次进入f后 内部最开始m=8进入f后 m的值变为m=15第二次调用 f 后 p=15首先需要明确的是，不管是在 main() 还是在 f() 中，m 都只是局部变量，作用域仅限于对应的函数中。在 main() 中，m 为 auto 型，函数调用结束后 m 的内存释放。而在 f() 中，m 是 static 型，也就是说，只有在程序结束后，其内存才会被释放，f 函数调用结束并不会释放他的内存。从输出结果也可以看到，第一次结束调用 f() 时，f() 中的 m 从1变成了 8，而在第二次调用 f() 时，并没有为 f() 中的 m 重新开辟空间，而是继续读取之前 m 所储存的空间，故最开始 m 的值仍为 8.register 型register 型变量储存在寄存器中，而非内存之中。因为寄存器读取速度比内存快一些，因此 register 类型读取更快。通常编译器会自主选择是否将某个变量变成 register 型。1.如果对寄存器变量使用＆运算符，则编译器可能会给出错误或警告（取决于您使用的编译器），因为当我们说变量是寄存器时，它可能存储在寄存器中而不是内存中，并且寄存器的访问地址无效。2.register关键字可以与指针变量一起使用。显然，寄存器可以具有存储位置的地址。以下程序不会有任何问题。3.寄存器是一个存储类，并且C不允许变量使用多个存储类说明符。因此，register不能与static一起使用。4.寄存器只能在一个块内使用（局部），而不能在全局范围内（在主外部）使用。5.C程序中对寄存器变量的数量没有限制，但重点是编译器可能会将某些变量放入寄存器中，而有些则不会。extern 型若要在全局变量声明之前使用它的值，则需要用到 extern 类型。如：#include&lt;cstdio&gt;using namespace std;extern int a,b; // 全局变量声明在最后面，可以提前声明来引用void f(){ printf(\"a=%d b=%d\",a,b);}int main(){ f(); return 0;}int a=3,b=2;最后输出结果：a=3 b=2实际上 extern 类型更常用于工程文件中，需要在一个 cpp 文件中调用另一个 cpp 文件的全局变量时，则需要用 extern 来声明。函数储存类型函数储存类型： 内部函数：只能被当前文件的函数调用的函数，储存类型：static 外部函数：可供其他文件的函数调用的函数，储存类型：extern默认省略储存类型的函数为 extern 外部函数。如果要调用外部文件必须： 被调函数为 extern 主调函数内必须用 extern 声明被调函数如：主调函数：#include&lt;cstdio&gt;using namespace std;extern int f(int );int main(){ f(1); return 0;}被调函数：#include&lt;cstdio&gt;using namespace std;int f(int n){ return n==1?f(n-1)*n;}" }, { "title": "结构体的拷贝", "url": "/posts/struct-cpy/", "categories": "", "tags": "", "date": "2022-05-22 14:28:09 +0800", "snippet": "引言在转专业考试的时候遇到一道，需要用到结构体排序，也就是说需要交换两个结构体。最开始的时候我想到的方法是利用指针：struct node{ int id,in; char name[20]; double ave;}stu[55];void swap(node* a,node* b){ \tnode t; t=*a; *a=*b; *b=t;}int main(){ node a,b; swap(&amp;a,&amp;b); return 0;}但是我还发现了一种其他写法：node t;t=a;a=b;b=t;上网查阅之后才知道原来结构体可以直接赋值。结构体之间赋值结构体之间是可以直接赋值的但要注意的是，如果含有指针，则要小心内存溢出[^1]。" }, { "title": "欧几里得算法求最大公约数", "url": "/posts/gcd/", "categories": "", "tags": "", "date": "2022-05-21 21:54:37 +0800", "snippet": "欧几里得算法对于两个数 $a,b$ $(a&gt;b)$ ，他们的最大公因数 $\\gcd(a,b)=\\gcd(b,a \\mod b)$，只需要如此辗转相除，直到 $a \\mod b=0$ 为止，此时的 $b$ 即为最大公约数。例子 $\\gcd(36,24)$ $=\\gcd(24,12)$ $=\\gcd(12,12)$ $=\\gcd(12,0)$ 因此 $\\gcd(36,24)=12$ 由于在 c 语言中，小数%大数=小数（如 3 % 10 = 3），故： $\\gcd(24,36)$ $=\\gcd(36,24)$ $=\\gcd(24,12)$ $=\\gcd(12,12)$ $=\\gcd(12,0)$ 因此，$\\gcd(a,b)$ 和 $\\gcd(b,a)$ 是等价的。代码#include&lt;cstdio&gt;using namespace std;int gcd(int a,int b){ return (b==0)?a:gcd(b,a%b);}int main(){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\",gcd(a,b)); return 0;}" }, { "title": "L1-033 出生年", "url": "/posts/L1033/", "categories": "题解, PAT", "tags": "格式化输出", "date": "2022-05-07 14:04:42 +0800", "snippet": "L1-033 出生年Description以上是新浪微博中一奇葩贴：“我出生于1988年，直到25岁才遇到4个数字都不相同的年份。”也就是说，直到2013年才达到“4个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于y年，直到x岁才遇到n个数字都不相同的年份”这句话。Input输入在一行中给出出生年份 y和目标年份中不同数字的个数n，其中y在[1, 3000]之间，n可以是2、或3、或4。注意不足4位的年份要在前面补零，例如公元1年被认为是0001年，有2个不同的数字0和1。Output根据输入，输出x和能达到要求的年份。数字间以1个空格分隔，行首尾不得有多余空格。年份要按4位输出。注意：所谓“n个数字都不相同”是指不同的数字正好是n个。如“2013”被视为满足“4位数字都不同”的条件，但不被视为满足2位或3位数字不同的条件。Sample Input 11988 4Sample Output 125 2013Sample Input 21 2Sample Output 20 0001分析仅需从出生年份 y 开始，逐个开始搜索即可。需要注意的是，如何理解 n，由题目可知：n 指的是年份用 0 补齐之后，不同数字的个数。如何维护 n 呢？首先是要保证年份被补齐，其次就是统计不同数字的个数。保证年份被补齐：可以通过字符数组来模拟：用一个字符数组 char num[5] 来存储年份，初始化赋值为 '0'，然后将整型的数字储存在这个字符数组之中，这样就实现了数字的补齐。Code#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int f[10]; // 用于统计个数，1为数字出现过，0为数字未出现int main(){ int y,n; scanf(\"%d%d\",&amp;y,&amp;n); for(int i=y;i&lt;=9999;i++){ // 穷举从当前年以后的所有四位年份 int t=i; // t储存当前枚举的年份 memset(f,0,sizeof(f)); char num[5]; // 用字符数组保存年份 memset(num,'0',sizeof(num)); int ptr=4; while(t!=0){ // 将整型年份储存在字符数组中 num[ptr--]=t%10+'0'; t/=10; } for(int j=1;j&lt;=4;j++){ f[num[j]-'0']=1; } int tot=0; for(int j=0;j&lt;=9;j++){ if(f[j]) tot++; // 统计当前年份不同数字个数 } if(tot==n){ printf(\"%d %04d\",i-y,i); return 0; } } return 0;}" }, { "title": "由C语言指针取值运算与自增运算引发的对于优先级的探讨", "url": "/posts/operators-precedence/", "categories": "", "tags": "", "date": "2022-05-07 10:15:23 +0800", "snippet": "引言在做一道题：在函数中统计某一数组的奇数和偶数个数，并通过指针传递值。原先我的代码是这样写的：void f(int a[],int n,int* odd,int* even){ for(int i=1;i&lt;=n;i++){ if(*(a+i)%2==0){ *even++; } else{ *odd++; } }}结果，最终输出奇偶数个数始终为0 0，在上网了解之后才发现应该改为：void f(int a[],int n,int* odd,int* even){ for(int i=1;i&lt;=n;i++){ if(*(a+i)%2==0){ (*even)++; // this is correct! } else{ (*odd)++; // this is correct! } }}++ 与 * 的优先级++ 与 * （取值运算）都是同级运算，且运算规则为从右向左，也就是说：*even++ 实际上是先 ++ ，再取值（取的是没有自增前的地址的值），这也就解释了为什么第一次代码结果始终0，因为这个操作实际上是将指针向后移一个 sizeof(int)，然后再顺便读取了自增之前的地址的值（实际上根本没有对任何所指向的变量进行修改，自始至终只有指针指向的地址变了）。这个写法通常用于遍历数组，例如：int main(){ int a[]={1,2,3,4,5,6,7,23,564,14,-1}; int *p=a; while(*p!=-1){ printf(\"%d\\n\",*p++); } return 0;}输出结果是：12345672356414再次说明了，*p++ 这个操作就是相当于：进行 p++ 这个操作（这个操作的左值就是自增前 p 所储存的地址），然后对这个地址取出所储存的元素。可以看作是：先取出了指针指向元素的值，再进行指针自增（这个仅仅是表象效果，背后的原理并非如此！！！）若想要修改 even 所指向元素的值，则可以改成：++*even 或者 (*even)++。其他运算符的优先级和关联性下表显示 C++ 运算符的优先级和关联性（从最高优先级到最低优先级）。 优先级别编号相同的运算符具有等同的优先级别，除非由括号显式施加另一种关系。 运算符说明 运算符 替代项 组 1 优先级，无关联性     范围解析 ::   组 2 优先级，从左到右关联     成员选择（对象或指针） 或 -&gt;   数组下标 [\\]   函数调用 ()   后缀递增 ++   后缀递减 --   类型名称 typeid   常量类型转换 const_cast   动态类型转换 dynamic_cast   重新解释的类型转换 reinterpret_cast   静态类型转换 static_cast   组 3 优先级，从右到左关联     对象或类型的大小 sizeof   前缀递增 ++   前缀递减 --   一个补充 ~ compl 逻辑不是 ! not 一元否定 -   一元加 +   地址 &amp;   间接寻址 *   创建对象 new   销毁对象 delete   投 ()   组 4 优先级，从左到右关联     指向成员的指针（对象或指针） 或 -&gt;*   组 5 优先级，从左到右关联     乘法 *   部门 /   模 %   组 6 优先级，从左到右关联     加法 +   减法 -   组 7 优先级，从左到右关联     左移 &lt;&lt;   右移 &gt;&gt;   组 8 优先级，从左到右关联     小于 &lt;   大于 &gt;   小于或等于 &lt;=   大于或等于 &gt;=   组 9 优先级，从左到右关联     等式 ==   不相等 != not_eq 组 10 优先级从左到右关联     按位 AND &amp; bitand 组 11 优先级，从左到右关联     位异或 ^ xor 组 12 优先级，从左到右关联     位或 | bitor 组 13 优先级，从左到右关联     逻辑与 &amp;&amp; and 组 14 优先级，从左到右关联     逻辑或 || or 组 15 优先级，从右到左关联     条件逻辑 ? :   分配 =   乘法赋值 *=   除法赋值 /=   取模赋值 %=   加法赋值 +=   减法赋值 -=   左移赋值 &lt;&lt;=   右移赋值 &gt;&gt;=   按位“与”赋值 &amp;= and_eq 按位“与或”赋值 |= or_eq 按位“异或”赋值 ^= xor_eq 引发表达式 throw   组 16 优先级，从左到右关联     逗号 ,   （reference：https://docs.microsoft.com/zh-cn/cpp/cpp/cpp-built-in-operators-precedence-and-associativity?view=msvc-170）" }, { "title": "图中的最短路径", "url": "/posts/shortest-path-again/", "categories": "图论, 算法", "tags": "图论, 最短路", "date": "2022-04-15 11:13:51 +0800", "snippet": "单源最短路Ford 算法（to be updated）Dijkstra 算法感谢邓俊辉老师！声明一下 Dijkstra 的音标：/ˈdɛɪkstra/假设你有一串珠子，珠子之间通过长度不同的线段连接而成，如何找出任意两珠子之间的最短路径？答案是，用手抓住两颗珠子，逐渐伸直，直线段的长度即为最小路径长度，线段上的珠子即为经过的节点。（如图所示）如何模拟这一个过程呢？如下图所示，假设有这么一个图，平摊在桌面上，先要找出从源点 S 到其他各个点的最短距离。仅需提起 S 点，其余的点逐个绷直地被提起来，即可求得最短路径。我们不妨先提起来一部分点，如图可以看见，整个所有点被划分为了两个部分，被提起来的绿色的部分（已经确定最短路径的），和未被提起来的蓝色部分。注意到边也被分为了三类，未提起来的点与提起来的点相连的粉红色边、提起来的点之间相连的绿色边、为提起来的点之间相连的蓝色边。其中要注意的，竖直边是最短路径。如何找出下一个被提起来的点是什么呢？显然绿色边的状态已经固定了，蓝色边要被绷直必然要先绷直粉红色边，也就是说，下一个被提起来的点必然与粉红色的边相连。因此，我们只需要搜索所有粉红色边（连接两个不同集合的点的边，又称作 bridge），对于任意与粉红色边相连的蓝色结点 $v$，他的最短距离\\(dist[v]=\\min \\left\\{\\begin{matrix} dist[v]\\\\dist[u]+e&lt;u,v&gt;\\\\\\end{matrix}\\right.\\)对于所有的蓝色结点中 $dist[v]$ 最小的就是会被提上去的点。定义一个集合 $S ={源点s + 已经确定了最短路径的 V}$（此处的确定最短路径是指，只用集合中收录了的点确定了最短路，也就是说每收录一个新的点，就有可能改变这个最短路径），定义数组 $dist[i]$ 表示 $s$ 到 $i$ 只经过集合 $S$ 中顶点的最短路径距离。怎么收录 $V$ 呢？我们每一次搜寻 $dist[i]$ 最小的且未收录的点到集合 $S$ 中（贪心）。由于收录的点可能与集合 $S$ 中的点存在边，也就是收录的点 $V$ 可能会改变其他点 $u$ 的最小路径 $dist[u]$（可能通过 $V$ 到 $u$ 距离会变短）。如图，未收录 $V$ （灰色表示）时，这个时候 $dist[u]=22$。若将 $V$ 收录后，则需要更新更新，集合中其他顶点的 $dist[]$ 值：为了维护集合中的点最短路是最小值，每一次收录一个顶点 $V$，对 $\\forall{u}\\in S $ ，$dist[u]=\\min(dist[u],dist[v]+e&lt;v,u&gt;)$ （$e&lt;v,u&gt;$ 为边 $vu$ 的权重）如图，由于 $dist[V]+e&lt;V,U&gt;=6+4=10&lt;d[U]=22$，故更新 $dist[U]=10$如图可知，此时收录至集合中的顶点（橙色）的 $dist$ 值都是最小的了。因此只要不断将新的点收录至集合中，就可以得到每个点到源点的最小距离。Dijkstra 的流程： 初始化边： e[i][j] = INF e[i][i] = 0 读入边 对源点 s 进行 Dijkstra 初始化： dist[i] = e[s][i] （s 为源点） v[i] = 0; v[s] = 1 未被提起来的点（集合 S 的点） path[i] = -1 ，path[i] 用于储存结点 i 的最短距离的前驱点（父节点） 找出未提起来的点当中 dist 最小的那个点 p（即桥最小相连的未被提起来的点） 把 p 收录进集合 S ，即 v[p] = 1 更新与他相连且未被提起来的点 v 的 dist，并且记录该节点的前驱点为 p，即 path[v] = p直接扫描未收录顶点#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;stack&gt;#define MAXN 1005#define INF 0x3f // 数量级 1e9，且不用担心 INF + INF 超出 int 范围using namespace std;int e[MAXN][MAXN]; \t\t// 邻接矩阵储存边 int dist[MAXN];\t\t\t// 用于记录节点 v 通过集合 S 中点的最小距离 int v[MAXN];\t\t\t// 记录是否访问过，访问过即加入了集合 S 中 int path[MAXN];\t\t\t// path[v] = u 记录 v 的最小距离前驱点为 uint n,m,edge; // n 节点数 m 边数 edge 边长 void Dijkstra(int s){\t// initialize\tfor(int i=1;i&lt;=n;i++){\t\tdist[i]=e[s][i];\t\tv[i]=0;\t\tpath[i]=-1;\t}\t\t// 把源点 s 加入集合 S\tv[s]=1;\tfor(int k=1;k&lt;=n;k++){ // 重复 n 次，保证每个节点都被加入集合 S \t\tint min=INF,p;\t\t// 找出桥中最短的所连接的未访问的点 p\t\tfor(int i=1;i&lt;=n;i++){\t\t\t\t\tfor(int j=1;j&lt;=n;j++){\t\t\t\tif(!v[j] &amp;&amp; dist[j]&lt;min){\t\t\t\t\tmin=dist[j];\t\t\t\t\tp=j;\t\t\t\t}\t\t\t}\t\t}\t\t\t// 把 p 加入集合 S\t\tv[p]=1;\t\t\t// 更新与 p 相邻的为加入 S 的点的 dist 和 path\t\tfor(int i=1;i&lt;=n;i++){\t\t\tif(!v[i] &amp;&amp; dist[i]&gt;dist[p]+e[p][i]){\t\t\t\tdist[i]=dist[p]+e[p][i];\t\t\t\tpath[i]=p;\t\t\t}\t\t} \t}\t}int main(){\tscanf(\"%d%d\",&amp;n,&amp;m);\t\t// initialize\tfor(int i=1;i&lt;=n;i++){\t\tfor(int j=1;j&lt;=n;j++){\t\t\te[i][j]=(i==j) ? 0 : INF; // 自己到自己距离为 0 \t\t}\t} \t\t// 读入边 \tfor(int i=1;i&lt;=m;i++){\t\tint u,v;\t\tscanf(\"%d%d%d\",&amp;u,&amp;v,&amp;edge);\t\te[u][v]=edge; // 有向图 \t}\t\t// 读入源点 s\tint s;\tscanf(\"%d\",&amp;s); \t\tDijkstra(s); \t\tfor(int i=1;i&lt;=n;i++){\t\tprintf(\"dist[%d]=%d\\n\",i,dist[i]);\t}\t\tint pnt;\tstack&lt;int&gt; p;\t\tfor(int i=1;i&lt;=n;i++){ // 倒叙输出到每个节点的最短路径 \t\tif(i==s) continue;\t\tpnt=i;\t\tprintf(\"%d\",i);\t\twhile(path[pnt]!=-1){\t\t\tprintf(\"-&gt;%d\",path[pnt]);\t\t\tpnt=path[pnt];\t\t\t\t\t}\t\tprintf(\"%d\\n\",s);\t}\t// 需要正序输出可以用栈 \treturn 0;} " }, { "title": "DFS", "url": "/posts/graph-again/", "categories": "图论, 算法", "tags": "DFS, 图的遍历, 最短路, 寻路", "date": "2022-04-14 17:13:37 +0800", "snippet": "DFS (depth-first-search)DFS 策略为：从一结点出发，挑选相邻结点进行搜索，若没有可走（没有结点或者是结点已搜索）结点，则回退至上一个结点继续搜索。寻路如何利用 DFS 进行寻路？bool dfs(s, d) { // s 为起点，d 为终点 \tif( s 为 d ) // 找到终点了\t\treturn true;\tif( s 为旧点 ) // s 已访问过\t\treturn false;\t将 s 标记为旧点; // 没访问过 s，标记为访问过 对和 s 相邻的每个节点 U { \t\tif( dfs(U, d) == true)\t\t\treturn true;\t}\treturn false; }若要记录路径，则需要引入一个路径数组：Node path[MAX_LEN]; // MAX_LEN取节点总数即可int depth;bool dfs(V, D) {\tif( V 为 D ){ // 找到终点了\t\tpath[depth] = V; \t\treturn true;\t}\tif( V 为旧点 ) // 已访问\t\treturn false;\t将 V 标记为旧点;\tpath[depth]=V; // 假设这一条路可以走，记录下当前结点\t++depth;\t对和 V 相邻的每个节点 U { // 深入\t\tif(dfs(U, D) == true) // U 可以到终点，则 V 也一定可以到终点\t\t\treturn true;\t} // 找不到终点，需要回溯到上一结点\t--depth; // 撤销当前记录的结点\treturn false;}int main(){\t将所有点都标记为新点;\tdepth = 0;\tif( dfs(起点, D)) {\t\tfor(int i = 0;i &lt;= depth; ++ i)\t\tcout &lt;&lt; path[i] &lt;&lt; endl;\t}}遍历void dfs(V) {\tif( V是旧点 )\t\treturn;\t将 V 标记为旧点;\t对和 V 相邻的每个点 U {\t\tdfs(U);\t} }int main() {\t将所有点都标记为新点;\twhile(在图中能找到新点k) \t\tdfs(k);}图的储存邻接矩阵用一个二维数组 G[i][j] 来储存图，其值表示结点 $i,j$ 之间的连接情况（如有边、无边、权重、方向等）遍历复杂度：$\\mathcal{O}(N^2)$邻接表利用链表或 vector 实现。遍历复杂度：$\\mathcal{O}(N+E)$" }, { "title": "STL - set", "url": "/posts/stl-set/", "categories": "数据结构", "tags": "STL", "date": "2022-04-13 19:38:48 +0800", "snippet": "setset 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。set 内部通常采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。和数学中的集合相似，set 中不会出现值相同的元素。如果需要有相同元素的集合，需要使用 multiset。multiset 的使用方法与 set 的使用方法基本相同。插入与删除操作 insert(x) 当容器中没有等价元素的时候，将元素 x 插入到 set 中。 erase(x) 删除值为 x 的 所有 元素，返回删除元素的个数。 erase(pos) 删除迭代器为 pos 的元素，要求迭代器必须合法。 erase(first,last) 删除迭代器在 范围内的所有元素。 clear() 清空 set。 insert 函数的返回值类型为 pair&lt;iterator, bool&gt;，其中 iterator 是一个指向所插入元素（或者是指向等于所插入值的原本就在容器中的元素）的迭代器，而 bool 则代表元素是否插入成功，由于 set 中的元素具有唯一性质，所以如果在 set 中已有等值元素，则插入会失败，返回 false，否则插入成功，返回 true；map 中的 insert 也是如此。迭代器set 提供了以下几种迭代器： begin()/cbegin()返回指向首元素的迭代器，其中 *begin = front。 end()/cend()返回指向数组尾端占位符的迭代器，注意是没有元素的。 rbegin()/crbegin()返回指向逆向数组的首元素的逆向迭代器，可以理解为正向容器的末元素。 rend()/crend()返回指向逆向数组末元素后一位置的迭代器，对应容器首的前一个位置，没有元素。以上列出的迭代器中，含有字符 c 的为只读迭代器，你不能通过只读迭代器去修改 set 中的元素的值。如果一个 set 本身就是只读的，那么它的一般迭代器和只读迭代器完全等价。只读迭代器自 C++11 开始支持。查找操作 count(x) 返回 set 内键为 x 的元素数量。 find(x) 在 set 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 end()。 lower_bound(x) 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，返回 end()。 upper_bound(x) 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，返回 end()。 empty() 返回容器是否为空。 size() 返回容器内元素个数。 set 自带的 lower_bound 和 upper_bound 的时间复杂度为 $\\mathcal{O}(\\log n)$。 但使用 algorithm 库中的 lower_bound 和 upper_bound 函数对 set 中的元素进行查询，时间复杂度为 $\\mathcal{O}(n)$。 set 没有提供自带的 nth_element。使用 algorithm 库中的 nth_element 查找第 $k$ 大的元素时间复杂度为 $\\mathcal{O}(n)$。 如果需要实现平衡二叉树所具备的 $\\mathcal{O}(\\log n)$ 查找第 $k$ 大元素的功能，需要自己手写平衡二叉树或权值线段树，或者选择使用 pb_ds 库中的平衡二叉树。" }, { "title": "L1-020 帅到没朋友", "url": "/posts/L1020/", "categories": "题解, PAT", "tags": "格式化输出", "date": "2022-04-13 17:16:12 +0800", "snippet": "L1-020 帅到没朋友Description当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。Input输入第一行给出一个正整数 $N(≤100)$，是已知朋友圈的个数；随后 $N$ 行，每行首先给出一个正整数 $K(≤1000)$，为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为 $5$ 位数字（从 $00000$ 到 $99999$ ），ID间以空格分隔；之后给出一个正整数 $M(≤10000)$，为待查询的人数；随后一行中列出 $M$ 个待查询的ID，以空格分隔。注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。Output按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。注意：同一个人可以被查询多次，但只输出一次。Sample Input 133 11111 22222 555552 33333 444444 55555 66666 99999 77777855555 44444 10000 88888 22222 11111 23333 88888Sample Output 110000 88888 23333Sample Input 233 11111 22222 555552 33333 444444 55555 66666 99999 77777455555 44444 22222 11111Sample Output 2No one is handsome分析根据题意，只需找出帅到没朋友的人满足以下： 没有在任何朋友圈中出现过 朋友圈仅有他一人（本来可以是朋友圈有多人且全是他自己，但根据题目保证所有K超过1的朋友圈里都至少有2个不同的人，因此这种情况下就是 $k=1$）但是要注意 ID 的编号方式，如 0 应该输出为 00000。实现方法1数组模拟实现，用数组 f[] 来储存是否出现过，没有出现过或朋友圈仅一人，值为 0，否则为 1。注意输出时候，首先要格式化输出五位数字，即 \"%05d\"，其次避免重复输出。实现方法2利用set避免重复输出（set 只能储存一个相同元素）。定义两个集合 s，s1，前者用于储存有朋友的人的 id，后者用于储存已输出的 id。cout&lt;&lt;setw(5)&lt;&lt;setfill('0')&lt;&lt;id 保证了是五位数输出。代码数组模拟#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 99999+6using namespace std;bool f[MAXN],v[MAXN];int main(){\tint n,k,m,id;\tmemset(f,0,sizeof(f));\tmemset(v,0,sizeof(v));\tscanf(\"%d\",&amp;n);\twhile(n--){\t\tscanf(\"%d\",&amp;k);\t\tfor(int i=1;i&lt;=k;i++){\t\t\tscanf(\"%d\",&amp;id);\t\t\tif(k==1&amp;&amp;!f[id]){\t\t\t\tbreak;\t\t\t}\t\t\tf[id]=1;\t\t}\t}\tscanf(\"%d\",&amp;k);\tbool start=1;\twhile(k--){\t\tscanf(\"%d\",&amp;id);\t\tif(!f[id]&amp;&amp;!v[id]){\t\t\tv[id]=1;\t\t\tif(start){\t\t\t\tprintf(\"%05d\",id);\t\t\t\tstart=0;\t\t\t}\t\t\telse{\t\t\t\tprintf(\" %05d\",id);\t\t\t}\t\t}\t}\tif(start){\t\tprintf(\"No one is handsome\");\t}\treturn 0;}set实现/*author: This is pioneersource: https://blog.csdn.net/mizifor666/article/details/107218013*/#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;iomanip&gt;using namespace std;int main(){ int n;//n个朋友圈 cin&gt;&gt;n; int k;//某朋友圈的好友个数 int id;//好友id int m;//查询人数 int num=0;//handsome人数 set&lt;int&gt; s,s1;//s存储朋友圈id，s1存储答案id for(int i=0;i&lt;n;i++) { cin&gt;&gt;k; if(k&gt;=2)//2人以上 { for(int j=0;j&lt;k;j++) { cin&gt;&gt;id; s.insert(id); } } else//单个人不加入set，因为查询到他时他直接为帅到没朋友 cin&gt;&gt;id; } cin&gt;&gt;m; for(int i=0;i&lt;m;i++) { cin&gt;&gt;id; if(s.find(id)==s.end()&amp;&amp;s1.find(id)==s1.end())//有朋友的id和已输出的id中无该id { if(num!=0) cout&lt;&lt;' '; s1.insert(id); cout&lt;&lt;setw(5)&lt;&lt;setfill('0')&lt;&lt;id;//保证id为五位 num++; } } if(num==0) cout&lt;&lt;\"No one is handsome\"; return 0;}" }, { "title": "C语言输出格式控制符", "url": "/posts/format-output/", "categories": "", "tags": "", "date": "2022-04-07 20:51:52 +0800", "snippet": "控制符通用格式其格式为 \"%[标志] [输出最小宽度] [.精度] [长度] 类型\"常见的 \"%.2lf\" 、\"%5d\" 等都是其中的一种。标志位 标 志 意义 - 结果左对齐，右边填空格 + 输出符号(正号或负号) 空格 输出值为正时冠以空格，为负时冠以负号 # 对c（字符）、s（字符串）、d（十进制有符号整型）、u（十进制无符号整型）类无影响； 对o（八进制无符号整型）类，在输出时加前缀o； 对x（十六进制无符号整型）类，在输出时加前缀0x； 对e（指数形式输出小数）、g（以%f、%e两者较短输出宽度的输出）、f（小数形式输出小数） 类当结果有小数时才给出小数点。 0 前导输出 0 占宽度。 示例如下：int a=-123, b=123;printf(\"%-7d%+d\", a, a);输出结果如下：-123 -123int a=-123,b=123;printf(\"% d %#x %05d\",a,b,b);-123 0x7b 00123输出最小宽度用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。若实际宽度大于定义宽度，则按实际宽度输出。.精度精度格式符以“.”开头，后跟十进制整数。作用为： 如果输出数字，则表示小数的位数； 如果输出的是字符，则表示输出字符的个数； 若实际位数大于所定义的精度数，则截去超过的部分。长度长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。long int a = 270000000;printf(\"long int = %d;int = %d.\\n\",sizeof(long int),sizeof(int));printf(\"|%d|%d|%d|\\n\",a,a,a);printf(\"|%hd|%ld|%d|\",a,a,a);/*******输出结果*******long int = 4;int = 4.|270000000|270000000|270000000||-8320|270000000|270000000| //短整型时出错了*********************/类型类型字符用以表示输出数据的类型，其格式符和意义如下表所示： 格式字符 意义 d 以十进制形式输出带符号整数(正数不输出符号) o 以八进制形式输出无符号整数(不输出前缀0) x,X 以十六进制形式输出无符号整数(不输出前缀Ox) u 以十进制形式输出无符号整数 f 以小数形式输出单、双精度实数 e,E 以指数形式输出单、双精度实数 g,G 以%f或%e中较短的输出宽度输出单、双精度实数 c 输出单个字符 s 输出字符串 " }, { "title": "【题解】情话鉴定器", "url": "/posts/love-teller/", "categories": "题解, PAT", "tags": "字符串", "date": "2022-03-27 22:46:02 +0800", "snippet": "[H]情话鉴定器DescriptionMr. High准备来到明理农场给Mr. Ox打工，赚点外快。明理农场的猪之间会相互通讯，而Mr. Ox想知道他们之间说话的内容，于是他让Mr. High开发一个情话鉴定器。情话鉴定器的功能很简单，如果通讯的内容中有 'I'、'love'、'you'（区分大小写）三个子串，并且它们按顺序出现，则这一段内容为情话，否则不是。Mr. Ox现在截取了若干段通讯记录，他希望你分辨出每一段记录是否为情话。子串：串中任意个连续的字符组成的子序列称为该串的子串。数据范围：假设字符串总长度为 $len$，则 $1 \\leq len \\leq 10^6$，字符串由大写字母、小写字母、数字、空格组成Input若干行每行代表一段通讯记录，当检测到输入单独一行为 Shu wan le 的时候，代表输入结束，之后的内容作废。输入保证至少存在一行 Shu wan le。Output在非作废内容中，对于 Shu wan le 之前的每一行，若这一行的通讯内容为情话，则输出 Yes，否则输出 No。Sample Input 1IaaaaaloveaaaaayouiaaaaaloveaaaaayouI love youI1love2you23333333love I youIloveyouShu wan leaaaaaaaaI love youSample Output 1YesNoYesYesNoYes分析题目要求很简单，就是要在读取终止前，判断每一行字符串，是否以此包含字串 I、love、you。借助 cstring 库函数 strstr()，判断非常容易，该函数的用法如下：const char *strstr(const char *str, const char *substr);该函数用返回 substr，在 str 中第一次出现的地址，如果没有找到，则返回 NULL。借助与这个函数我们即可轻松地找到字串了。如果找到 I，将它的地址记作 indexI，那么只需查找 strstr(indexI, love) 即可。代码#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 1000001const char END[]=\"Shu wan le\";const char I[]=\"I\";const char love[]=\"love\";const char you[]=\"you\";char str[MAXN];int main(){\tgets(str);\tint start=1;\twhile(strcmp(str,END)!=0){\t\tif(!start) printf(\"\\n\");\t\telse start=0;\t\tchar* indexI=strstr(str,I);\t\tif(indexI==NULL){\t\t\tprintf(\"No\");\t\t\tgets(str);\t\t\tcontinue;\t\t}\t\tchar* indexLove=strstr(indexI,love);\t\tif(indexLove==NULL){\t\t\tprintf(\"No\");\t\t\tgets(str);\t\t\tcontinue;\t\t}\t\tchar* indexYou=strstr(indexLove,you);\t\tif(indexYou==NULL){\t\t\tprintf(\"No\");\t\t\tgets(str);\t\t\tcontinue;\t\t}\t\tprintf(\"Yes\");\t\tgets(str);\t}\treturn 0;}" }, { "title": "质数", "url": "/posts/prime-number/", "categories": "数学", "tags": "质数", "date": "2022-03-24 23:04:46 +0800", "snippet": "质数判断试除法：用所有可能因数去除该数，若余数为 $0$，则为合数，否则为质数。最朴素的做法就是穷举 $[2, n)$ 之间的所有数来除该数。实际上，只需穷举至 $ \\sqrt{n} $ 即可。假设合数 $k$ 有且仅有因数 $f \\in ( \\sqrt{n},n)$，显然 $k$ 还有一个因数 $g = \\frac{k}{f}$，由于 $f &gt; \\sqrt{n}$，则 $g &lt; \\sqrt{n}$，故假设不成立。因此合数必然有小于等于 $\\sqrt{n}$ 的因数。算法时间复杂度为：$\\mathcal{O}(\\sqrt{n})$。代码如下：bool isPrime(int x){ // 试除法\tif(x&lt;2) return 0; // 0,1均不是质数也不是合数 \tfor(int i=2;i&lt;=sqrt(x);i++){\t\tif(x%i==0) return 0;\t}\treturn 1;}质数筛选Eratosthenes 筛选质数的倍数一定是合数，因此可以通过穷举质数的倍数，从而达到筛选出合数，得到质数的效果。最经典朴素的筛法就是 Eratosthenes 筛法（埃氏筛法）注意，对于一个质数 $i$，由于对于倍数 $n&lt;i$，数 $ni$ 已经在得到质数 $i$ 之前被筛选过了，因此只需要从倍数 $n=i$ 开始枚举即可。bool prime[MAXN];void primes(int n){ // Eratosthenes 筛法 \t// 记得初始化 prime[] 为 1 memset(prime,1,sizeof(prime))\tfor(int i=2;i&lt;=n;++i){ // 从 2 开始筛选到 n \t\tif(!prime[i]) // 数跳过 \t\t\tcontinue;\t\tfor(int j=i;j&lt;=n/i;j++) // 从 x^2 开始筛，x*i（在 i 小于 x 时）已经筛选过 \t\t\tprime[i*j]=0; \t}\tfor(int i=2;i&lt;=n;i++){\t\tif(prime[i])\t\t\tprintf(\"in primes(): %d\\n\",i);\t}}线性筛选Eratosthenes 筛选即使是从 $i^2$ 开始筛选，仍然会重复筛选，例如 $12 = 2 \\times 6 = 3 \\times 4$，实际上是有重复的。对于任意合数 $c$，其都可以表示为 $c=p_1^{k_1} p_2^{k_2} …p_n^{k_n}$（$p_1,p_2,…,p_n \\in \\mathbb{P}$，$k_1,k_2,…,k_n \\in \\mathbb{N^+}$），故只需要将质数累乘起来，即可筛选出合数。例如 $12=2^2 \\times 3$。对于 $i \\in [2,n]$，用一个数组 prime_factor[i] 来储存 $i$ 的最小质因数。初始化 prime_factor[i]=0，若穷举到 $i$ 的对应 prime_factor[i]=0，则说明他是质数，令 prime_factor[i]=i，并记录下该质数。为了维护 prime_factor[]，每一轮循环都要穷举已知的质数 prime[j]，用 prime[j] 来替换 prime_factor[i*prime[j]]，因为 prime[j] &lt; i 因此维护了 prime_factor[] 的统一，因此需要保证 prime[j] 是最小的，故 prime[j] &gt; prime_factor[i] 时需要退出循环void linearPrimes(int n){ // 线性筛法 \tint primenum=0; \t// prime_factor 用于储存 i 的最小质因子\t// 储存了最小质因子，就是合数，为 0 说明没有被筛掉，是质数 \tmemset(prime_factor,0,sizeof(prime_factor));\tfor(int i=2;i&lt;=n;i++){\t\tif(prime_factor[i]==0){ // i 没有被筛掉，所以是合数 \t\t\tprime_factor[i]=i;\t\t\tnprime[++primenum]=i;\t\t}\t\tfor(int j=1;j&lt;=primenum;j++){\t\t\tif(nprime[j]*i&gt;n||nprime[j]&gt;prime_factor[i]){\t\t\t\t// 所筛的数字大于最大数字或者数字 i 的最小质因子更小\t\t\t\tbreak; \t\t\t}\t\t\tprime_factor[i*nprime[j]]=nprime[j];\t\t}\t}\tfor(int i=1;i&lt;=primenum;i++){\t\tprintf(\"in linearPrimes(): %d\\n\",nprime[i]);\t}} " }, { "title": "【题解】文档处理", "url": "/posts/document-process/", "categories": "题解, PAT", "tags": "字符串", "date": "2022-03-23 17:03:18 +0800", "snippet": "题面Description明理农场收到了一份文档，这份文档很长，Mr. Ox 看不懂，他需要你来处理一下这份文档。这是一篇长度为 $n$，由大写字母'A'-'Z'、小写字母'a'-'z'和空格组成的文档，他需要你统计出每一段连续字母的个数，并将所有空格符' '替换为'-'。比如Good luck，处理之后为1G2o1d-1l1u1c1k。在处理完文档之后，你需要将处理的结果进行输出。数据范围：$1 \\leq n \\leq 10^5$Input一行一个字符串表示文档的内容。Output一行一个字符串表示处理后的内容。Sample Input 1Wooooo AAAAAKKKKK leEeSample Output 11W5o-5A5K-1l1e1E1e分析朴素的做法：模拟数数过程，从 str[0] 开始计数，初始化 count = 1。如果遇到空格，直接输出 - 然后跳过。如果遇到当前字符与下一个字符不相同，说明我们需要输出当前计数的字符了并且重置计数器 count = 1，否则 count ++。检查的时候可以测试一下特殊数据：| Input | Output || :———: | :——: || ` （空格） | - || a | -1a || aa | -2a || aab ` | -2a1b- || aa bb | 2a-2b |代码#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define MAXN 100005using namespace std;char str[MAXN]; int main() {\tgets(str);\tint count = 1;\tfor(int i = 0; i &lt; strlen(str); i++) {\t\tif(str[i] == ' ') {\t\t\tprintf(\"-\");\t\t\tcontinue;\t\t}\t\tif(str[i] != str[i + 1]) {\t\t\tprintf(\"%d%c\", count, str[i]);\t\t\tcount = 1;\t\t}\t\telse {\t\t\tcount++;\t\t}\t}\treturn 0;}" }, { "title": "P2141[NOIP2014 普及组] 珠心算测验题解", "url": "/posts/P2141/", "categories": "题解", "tags": "", "date": "2022-03-06 20:13:12 +0800", "snippet": "题目关键正整数集合，各不相同，其中有多少个数，恰好等于集合中另外两个（不同的）数之和？说明 正整数，也就是不含 $0$；（题外话，如果含 $0$，则直接用桶来统计会出错） 题目问的是有多少个数 $a[i]$ 满足 $a[i]=a[j]+a[k]$，因此只要统计到一个 $a[i]$ 就应该结束当前对 $a[i]$ 的搜索，接着搜索 $a[i+1]$。（得30分多半就是对这句话理解不当） 解题思路直接模拟，用 $i,j,k$ 当指针，固定 $i$ ，然后用 $j,k$ 逐个搜索，当 $a[i]=a[j]+a[k]$ 时，break $j,k$ 循环即可。代码// https://www.luogu.com.cn/problem/P2141#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;int a[101];int main(){\tint n;\tscanf(\"%d\",&amp;n);\tfor(int i=1;i&lt;=n;i++){\t\tscanf(\"%d\",&amp;a[i]);\t}\t// count统计满足条件的a[i]\t// isifound用于标记a[i]是否找到，便于跳出循环。0为未找到 \tint count=0,isifound=0;\tfor(int i=1;i&lt;=n;i++){\t\tfor(int j=1;j&lt;=n;j++){\t\t\tif(j==i) continue;\t\t\tfor(int k=j+1;k&lt;=n;k++){\t\t\t\tif(k==i) continue;\t\t\t\tif(a[i]==a[j]+a[k]){\t\t\t\t\tisifound=1; \t\t\t\t//\tprintf(\"a[%d]=%d a[%d]=%d a[%d]=%d\\n\",i,a[i],j,a[j],k,a[k]);\t\t\t\t\tcount++;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t\tif(isifound){\t\t\t\tisifound=0; // 记得重设 \t\t\t\tbreak;\t\t\t}\t\t}\t}\tprintf(\"%d\",count);\treturn 0;} " }, { "title": "NOIP选手必知的编程技巧", "url": "/posts/knowledge-for-oiers/", "categories": "实用", "tags": "", "date": "2019-01-27 19:58:59 +0800", "snippet": "原文链接本文将给各位介绍一些无论是平时训练或者参加比赛时都比较有用的编程技巧，它们可以让我们的程序可读性更强，方便我们的调试，有些技巧甚至可以帮助我们获得更多的分数。PS：本文已经同步发表于我的博客，欢迎各位dalao前来围观。（戳这里）重载运算符重载运算符是通过对运算符的重新定义，使得其支持特定数据类型的运算操作。有的时候，我们构造了一种新的数据类型（高精度数，矩阵），当然可以将数据类型的运算操作用函数的形式写出来。但采用重载运算符的方式，可以让程序更为自然。当然，重载运算符在语法上也有一些要求：重载运算符的一般形式为返回值类型 operator 运算符(参数,…)在结构体内部重载运算符时，括号内的参数会少一个（事实上，另外一个参数是this指针，即指向当前参数的指针（这个不重要啦，你只需要知道就好）），也就是说，两元运算符只需要1个参数。（在结构体外部定义时，两元运算符还是需要2个参数）其他要求就和普通函数的要求差不多了。举一个简单的例子：#include &lt;stdio.h&gt;struct pair_num//一个二元组类型{ int x,y; pair_num operator +(pair_num a)const //不加const会CE { pair_num res; res.x=x+a.x;//x事实上是this.x res.y=y+a.y; return res; } pair_num operator -(pair_num a)const { pair_num res; res.x=x-a.x; res.y=y-a.y; return res; } bool operator &lt;(pair_num a)const //sort,set等数据结构需要使用小于号 { return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y); }}a,b,res;pair_num operator *(pair_num a,pair_num b)//在结构体外部定义时，不要加const{ pair_num res; res.x=a.x*b.x; res.y=a.y*b.y; return res;}int main(){ scanf(\"%d%d\",&amp;a.x,&amp;a.y); scanf(\"%d%d\",&amp;b.x,&amp;b.y); res=a+b; printf(\"%d %d\\n\",res.x,res.y); res=a-b; printf(\"%d %d\\n\",res.x,res.y); res=a*b; printf(\"%d %d\\n\",res.x,res.y); return 0;}namespace的用法在C++程序中，我们往往会加上using namespace std;这一行语句，那么它是干嘛的呢？事实上，C++引入了一个叫做名字空间(namespace)的机制。引入这个机制的目的，是为了解决程序中变量/函数名重复的问题。举个栗子：我写了一个solve()函数，另外一个人也写了一个solve()函数，如果把这两个函数放在一个程序里面，就会出现函数重名的问题。（当然，如果函数的参数列表不同（即参数个数和参数类型不同），是可以重载函数的，但仅仅是返回值不同时，不能重载函数）这时，我可以把我的solve()函数放在namespace code1中，把另一个人的solve()放在namespace code2当中，然后，通过code1::solve();语句就可以调用我写的solve()函数，code2::solve()可以调用另外一个人的solve()函数。写成代码大概是这样的：//P4774 NOI2018 屠龙勇士//根据自己在同步赛上写的骗分代码改编而成//总共拿了40分#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;long long n,m,a[100005],p[100005],aw[100005],atk[100005];namespace one_game{ //其实namespace里也可以声明变量 void solve() { for(int y=0;;y++) if((a[1]+p[1]*y)%atk[1]==0) { cout&lt;&lt;(a[1]+p[1]*y)/atk[1]&lt;&lt;endl; return; } }}namespace p_1{ void solve() { if(atk[1]==1)//solve 1-2 { sort(a+1,a+n+1); cout&lt;&lt;a[n]&lt;&lt;endl; return; } else if(m==1)//solve 3-4 { long long k=atk[1],kt=ceil(a[1]*1.0/k); for(int i=2;i&lt;=n;i++) k=aw[i-1],kt=max(kt,(long long)ceil(a[i]*1.0/k)); cout&lt;&lt;k&lt;&lt;endl; } }}int main(){ int T; cin&gt;&gt;T; while(T--) { memset(a,0,sizeof(a)); memset(p,0,sizeof(p)); memset(aw,0,sizeof(aw)); memset(atk,0,sizeof(atk)); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;p[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;aw[i]; for(int i=1;i&lt;=m;i++) cin&gt;&gt;atk[i]; if(n==1&amp;&amp;m==1)one_game::solve();//solve 8-13 else if(p[1]==1)p_1::solve();//solve 1-4 or 14-15 else cout&lt;&lt;-1&lt;&lt;endl; } return 0;}事实上，C++标准库把所有的函数都放在了namespace std当中，所以我们调用这些函数的时候，应该采用std::xxx的形式来调用标准库中的函数。当然，在加入using namespace std;一行后，就可以省略std::了，我们就可以偷懒了。（其实using namespace std;在工程上不推荐使用，但各位OIer们平时使用也没有什么问题）当然，我们在比赛的时候，可以通过使用namespace来使我们的程序结构更加规整。比较常见的用法就是针对每个子任务（诸如上面的屠龙勇士），各写一个namespace，在其中定义我们解决该子任务所需要的变量与函数，这样各个子任务间互不干扰，方便了我们这些蒟蒻们骗分，也降低了正解爆炸的分数损失。（对于那些AK IOI的巨佬们，这句话当我这个蒟蒻没说）善用标识符进行调试我们在本地测试的时候，往往要加入一些调试语句。要提交到OJ的时候，就要把他们全部删除，有些麻烦。我们可以通过定义标识符的方式来进行本地调试。大致的程序框架是这样的：#define DEBUG#ifdef DEBUG //do something#endif// or#ifndef DEBUG //do something#endif#ifdef会检查程序中是否有通过#define定义的对应标识符，如果有定义，就会执行下面的内容，#ifndef恰恰相反，会在没有定义相应标识符的情况下执行后面的语句。我们提交程序的时候，只需要将#define DEBUG一行注释掉即可。当然，我们也可以不在程序中定义标识符，而是通过-DDEBUG的编译选项在编译的时候定义DEBUG标识符。这样就可以在提交的时候不用修改程序了。PS:不少OJ（包括洛谷,poj,Codeforces等主流OJ）都开启了-DONLINE_JUDGE这一编译选项，enjoy it!对拍有的时候我们写了一份代码，但是不知道它是不是正确的。这时候就可以用对拍的方法来进行检验或调试。什么是对拍呢？具体而言，就是通过对比两个程序的输出来检验程序的正确性。你可以将自己程序的输出与其他程序（打的暴力或者其他dalao的标程）的输出进行对比，从而判断自己的程序是否正确。当然，我们不能自己比对两段程序的输出，所以我们需要通过批处理的方法来实现对拍的自动化。具体而言，我们需要一个数据生成器，两个要进行对拍的程序。每次运行一次数据生成器，将生成的数据写入输入文件，通过重定向的方法使两个程序读入数据，并将输出写入指定文件，利用Windows下的fc命令比对文件（Linux下为diff命令），从而检验程序的正确性。如果发现程序出错，可以直接利用刚刚生成的数据进行调试啦。对拍程序的大致框架如下：#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ //For Windows //对拍时不开文件输入输出 //当然，这段程序也可以改写成批处理的形式 while(1) { system(\"gen &gt; test.in\");//数据生成器将生成数据写入输入文件 system(\"test1.exe &lt; test.in &gt; a.out\");//获取程序1输出 system(\"test2.exe &lt; test.in &gt; b.out\");//获取程序2输出 if(system(\"fc a.out b.out\")) { //该行语句比对输入输出 //fc返回0时表示输出一致，否则表示有不同处 system(\"pause\");//方便查看不同处 return 0; //该输入数据已经存放在test.in文件中，可以直接利用进行调试 } }}写数据生成器的几个小提示在使用rand()前，别忘了调用srand(time(NULL))来重置随机数种子。（不重置的话，每次调用rand()只会得到一套随机数）rand()的生成随机数范围在Windows下为 [0,32767][0,32767] ，在Linux下为 [0,231−1][0,2 31 −1] ，所以如果数据过大，最好手写一个随机数生成器。（关于随机数生成器，可以见一位dalao在CF上的文章）。选择合适的编译选项这里介绍一些常用的编译选项。他们会对我们的编程工作起到一定程度的帮助。一般情况下，作者常用的编译选项是g++ a.cpp -o a -g -Wall -std=c++11。（-std=c++11只是作者有的时候会开启C++11玩玩而已，然而NOI/NOIP并没有C++11）而CCF在NOIP评测时的编译选项（C++）为g++ a.cpp -o a -lm。-Wall:显示所有警告信息。当我们的程序出现一些逻辑或语义上的问题时（包括未使用的变量，逻辑运算符的优先级问题，嵌套if语句的else配对问题），开启这个编译选项会显示这些警告信息，这样就可以减轻我们的调试负担。-g:调试的时候必须打开，这样才能使用gdb进行调试。-Ox:优化选项。一般能见到的优化选项有-O1 -O2 -O3三种，其中用的最多（大多数比赛（包括NOI）都会开启，但NOIP没有）的优化选项是-O2。打开优化选项有时（尤其在使用STL时）能减少程序运行时间，但会给单步调试带来一些麻烦，有的时候也会出现负优化。（注意：在程序中加入#pragma GCC optimize(2)并不会在NOIP评测时开启优化）-DDEBUG:这个在讲到用标识符进行调试的时候介绍过，是在编译阶段定义DEBUG标识符，当然这里定义的标识符也可以替换为其他的标识符，例如-DTEST会在编译阶段定义TEST标识符。考场上的一些注意事项以下内容供各位OIer们参考，欢迎补充。记得经常按Ctrl+S保存一下程序！（提到这一点是因为我市去年提高组的时候考场突然停电，不少人没有保存的程序瞬间灰飞烟灭，还有些人存盘的位置不对，重启的时候程序也没了）打的代码最好不要删除，用//注释掉是一个更好的主意，说不定以后要用。输出64位整数时请记得使用%lld！（当然也可以使用cin/cout来解决这个问题，别忘了加上ios::sync_with_stdio(false);防止IO耗时过久）别忘了算内存，有可能你不小心多输了一个0就MLE了。（一般情况下，256M内存的话，int数组最多可以开到 5∗1075∗10 7 ）比赛前最后15分钟一定要检查一下自己的所有代码，包括如下内容：一些调试语句是否已经被注释，源代码/输入文件/输出文件的文件名是否正确，一些不该被注释的语句（freopen以及fclose）是否删去注释。NOIP赛场上STL一定要根据实际情况（时间限制以及数据规模）谨慎使用！（当然，如果你是NOI玩家，当我什么都没有说）常见作死错误列表，各位一定要注意！最重要的一点！时刻记得这句话：“Keep it simple and stupid.”上了考场不要慌张，尽自己全力取得最好的成绩，你一定不会为此感到后悔！附录参考文献：刘汝佳《算法竞赛入门经典（第2版）》cpperference.com特别感谢各位dalao们的支持：我校@xqmmcqs和@李航博两位学长传授他们的OI经验，没有他们带给我的启发，就不会有本文的诞生；管理员@ComeIntoPower辛勤的审核；@woshiluo和@BeyondLimits两位dalao帮本蒟蒻审稿。最后，祝各位NOIP2018 RP++！" }, { "title": "线段树", "url": "/posts/seg-tree/", "categories": "数据结构, 算法", "tags": "线段树", "date": "2019-01-25 10:56:02 +0800", "snippet": "#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 100001using namespace std;struct segTree{ int l, r; long long sum;}t[MAXN*4];inline long long read(){ int f=1; long long x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){ if(ch=='-') f=-1; ch=getchar(); } while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=x*10+ch-'0'; ch=getchar(); } return x*f;}int n,m;int a[MAXN];void build(int id,int l,int r){ t[id].l=l,t[id].r=r; if(l==r){ t[id].sum=a[l]; return; } int mid=(l+r)&gt;&gt;1; build(id*2,l,mid); build(id*2+1,mid+1,r); return;}void updata(int id,int i,int x){ if(t[id].l==t[id].r){ // updata leaf node t[id].sum+=x; return; } int mid=(t[id].l+t[id].r)&gt;&gt;1; if(i&lt;=mid) updata(id*2,i,x); // i is in the left child else updata(id*2+1,i,x); // i is in the right child t[id].sum=t[id*2].sum+t[id*2+1].sum; // updata father node return;}long long ask(int id,int l,int r){ long long ans=0; if(t[id].l&gt;=l&amp;&amp;t[id].r&lt;=r) // still needs thinking return t[id].sum; int mid=(t[id].l+t[id].r)&gt;&gt;1; if(mid&gt;=l) ans+=ask(id*2,l,r); // the interval is in the left if(mid&lt;r) ans+=ask(id*2+1,l,r); // in the right return ans;}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); memset(a,0,sizeof(a)); build(1,1,n); // can only updata after being built int temp=4*n; for(int i=1;i&lt;=temp;++i){ t[i].sum=0; } int k; long long a,b; for(int i=1;i&lt;=m;++i){ scanf(\"%d%lld%lld\",&amp;k,&amp;a,&amp;b); if(k==0){ updata(1,a,b); } else{ printf(\"%lld\\n\",ask(1,a,b)); } } return 0;}" }, { "title": "CQOI2006 简单题", "url": "/posts/CQOI2006-simple/", "categories": "题解", "tags": "树状数组, 前缀和", "date": "2019-01-24 15:59:08 +0800", "snippet": "CQOI 2006 T1题目描述：有一个 n 个元素的数组，每个元素初始均为 0 。有 m 条指令，要么让其中一段连续序列数字反转——0 变 1，1 变 0（操作1），要么询问某个元素的值（操作2）。例如当 n=20 时，10 条指令如下：输入格式：输入文件第一行包含两个整数 n，m，表示数组的长度和指令的条数，以下 m 行，每行的第一个数 t 表示操作的种类。若 t=1，则接下来有两个数 L, R (L ≤ R)，表示区间 [L, R] 的每个数均反转；若 t=2，则接下来只有一个数 I，表示询问的下标。输出格式：每个操作 2 输出一行（非0即1），表示每次操作 2 的回答。样例数据：输入20 101 1 102 62 121 5 122 62 151 6 161 11 172 122 6输出100011【数据范围】50% 的数据满足：1 ≤ n ≤ 1,000，1 ≤ m ≤ 10,000100% 的数据满足：1 ≤ n ≤ 100,000，1 ≤ m ≤ 500,000分析一个浅显的道理：对一个数 $p$ 取反偶数次后的结果仍是 $p$。所以根据题意，若使某一个区间内的所有数都取反，那么不妨考虑为直接+1, 如果加完后是偶数那么就是0，否则为1。考虑到数据范围，暴力依次加1是肯定不可能的，于是可以利用树状数组维护前缀和求解。那么查询值的时间复杂度为 $\\mathcal{O}(\\log{}_2N)$。Code#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#define MAXN 100001using namespace std;int c[MAXN];int n,m;inline int read(){ int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){ if(ch=='-') f=-1; ch=getchar(); } while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=x*10+ch-'0'; ch=getchar(); } return f*x;}int lowbit(int x){ return x&amp;-x; }void add(int i,int x){ for(;i&lt;=n;i+=lowbit(i)){ c[i]+=x; }}int find(int x){ int ans=0; for(;x;x-=lowbit(x)){ ans+=c[x]; } return ans;}int main(){ cin&gt;&gt;n&gt;&gt;m; memset(c,0,sizeof(c)); int t,r,l; for(int i=1;i&lt;=m;++i){ t=read();l=read(); if(t==1){ r=read(); add(l,1); add(r+1,-1); } else{ printf(\"%d\\n\",find(l)%2); } } return 0;}" }, { "title": "KMP", "url": "/posts/kmp/", "categories": "算法", "tags": "字符串, KMP", "date": "2019-01-22 12:01:04 +0800", "snippet": "前言首先介绍一个最为关键的概念:next[] 数组：定义next[i]表示模式串中以i结尾的前缀串与后缀串能够匹配的最大长度。什么意思呢？以ababccab为例：（以1开始标号）根据定义next[1]=next[2]=0;当i=3时，有aba其前缀有：a, ab，后缀有：a, ba故next[3]=1（最长就为a）当i=4时，前缀有：a, ab, aba，后缀有b, ab, bab, 最长长度ab为2；当i=5时，前缀有：a, ab, aba, abab，后缀有c, bc, abc, babc，匹配失败，故为0；当i=6时，前缀有：a, ab, aba, abab, ababc，后缀有c,cc, bcc, abcc, babcc, 同理为0；当i=7时，前缀有：a, ab, aba, abab, ababc, ababcc，后缀有a,ca,cca,bcca,abcca,babcca，最长为a为1当i=8时（终于要写完了，累死），前缀有：a, ab, aba, abab, ababc, ababcc, ababcca，后缀有b,ab,cab,ccab,bccab,abccab,babccab，最长为ab为2；所以数组next[]为0 0 1 2 0 0 1 2在实践的过程中，不难发现有很多地方其实是重复了的，无论是在匹配字符串，还是求next[]数组，这种利用重复的思想都是至关重要的！！求next[]的方法先安利一本书《算法竞赛进阶指南》，感谢作者lyd，帮助我理解了上述”重复“的思想是如何贯穿于整个算法中的。当一个位置上的i的next[i]的值是大于0的，也就意味着前文一定有与之重复的地方，那么我在匹配的时候一定可以往前再次进行匹配具体请看下图：KMP同理，利用这种重复的思想就有了KMP算法：请见代码，（我深知我讲的十分不详细，讲的详细不是本篇博文的目的，我只是尽可能地希望读者能够体会到这种”重复的思想“）Code#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define MAXN 1010using namespace std;char mainstr[MAXN],modestr[MAXN];int next[MAXN];int n,m;void make_next(const char modestr[]){ next[1]=0; //根据定义 for(int i=2,j=0;i&lt;=n;++i){ while(j&gt;0&amp;&amp;modestr[i]!=modestr[j+1]){ // 不匹配，找前面的，直到到开头（j=0） j=next[j]; } if(modestr[i]==modestr[j+1]){ // 如果不知道为什么要+1请输出next[] j++; // 成功 } next[i]=j; }}int KMP(const char mainstr[],const char modestr[],const int next[]){ int ans=0; for(int i=1,j=0;i&lt;=m;++i){ while(j&gt;0&amp;&amp;(j==n||mainstr[i]!=modestr[j+1])){ // j==n表示主串中已经找到一处匹配项了 j=next[j]; } if(modestr[j+1]==mainstr[i]){ j++; } if(j==n){ ans++; } } return ans;}int main(){ scanf(\"%s%s\",mainstr+1,modestr+1); n=strlen(modestr+1); m=strlen(mainstr+1); make_next(modestr); printf(\"%d\\n\",KMP(mainstr,modestr,next)); return 0;}:)" }, { "title": "YBT1395 烦人的幻灯片", "url": "/posts/YBT1395/", "categories": "题解", "tags": "图论, 拓扑排序", "date": "2019-01-21 20:32:33 +0800", "snippet": "传送门没想到这道题竟然把我绕晕了，晕题目 问题描述 李教授将于今天下午作一次非常重要的演讲。不幸的是他不是一个非常爱整洁的人，他把自己演讲要用的幻灯片随便堆在一起。因此，演讲之前他不得不去整理这些幻灯片。做为一个讲求效率的学者，他希望尽可能简单地完成它。教授这次演讲一共要用n张幻灯片（n≤26），这n张幻灯片按照演讲要使用的顺序已经用数字1，2，…，n在上面编了号。因为幻灯片是透明的，所以我们用大写字母A，B，C，…再次把幻灯片依次编号。你的任务是编写一个程序，把幻灯片的数字编号和字母编号对应起来，显然这种对应应该是唯一的；若是出现多种对应的情况或是某些数字编号和字母编号对应不起来，我们就称对应是无法实现的。 输入文件（slides.in） 文件的第1行只有一个整数n，表示有n张幻灯片，接下来的n行每行包括4个整数Xmin，Xmax，Ymin，Ymax（整数之间用空格分开）为幻灯片的坐标，这n张幻灯片按其在输入文件中出现的顺序从前到后依次编号为A，B，C，…，再接下来的n行依次为n个数字编号的坐标x，y，显然在幻灯片之外是不会有数字的。 输出文件（slides.out） 若是对应可以实现，则输出文件包括n行，每一行一个字母和一个数字，中间一个空格，各行以字母的升序排列；若是对应无法实现，在文件的第一行顶格输出None即可。 样例输入 46 22 10 204 18 6 168 20 2 1810 24 4 89 1519 1711 721 11 样例输出 A 4B 1C 2D 3分析首先翻译一下题面：先给你幻灯片张数，每张幻灯片都已知一个范围，且每个范围根据输入顺序分别记录为A、B、C…然后再给你具体坐标，坐标分别标号为1、2、3…，要你求这些坐标分别属于哪一个范围。根据上述翻译我们把输入样例分析一下后，就有：也就是：\\(1 \\in{} A,B,C\\)\\(2 \\in{} A,C\\)\\(3 \\in{} B,C,D\\)\\(4 \\in{} A\\)以A-4开始逐渐消去，便可得到答案，具体实现请看下面代码Code中间有很多注释掉的语句是调试时用的，有兴趣的同学可以去掉注释输出来看便于理解每个语句的作用#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define MAXN 30using namespace std;struct node{ int x1,x2,y1,y2;}letter[MAXN];struct nodee{ int x,y;}number[MAXN];int n;int out[MAXN],path[MAXN],e[MAXN][MAXN];queue &lt;int&gt; q;bool judge(int n,int l){ // judge whether num n points to letter l return number[n].x&gt;=letter[l].x1 &amp;&amp; number[n].x&lt;=letter[l].x2 &amp;&amp; number[n].y&gt;=letter[l].y1 &amp;&amp; number[n].y&lt;=letter[l].y2;}int main(){ cin&gt;&gt;n; // initialization for(int i=1;i&lt;=n;++i){ out[i]=0; } for(int i=1;i&lt;=n;++i){ for(int j=1;j&lt;=n;++j){ e[i][j]=0; } } for(int i=1;i&lt;=n;++i){ cin&gt;&gt;letter[i].x1&gt;&gt;letter[i].x2&gt;&gt;letter[i].y1&gt;&gt;letter[i].y2; } for(int i=1;i&lt;=n;++i){ cin&gt;&gt;number[i].x&gt;&gt;number[i].y; } for(int i=1;i&lt;=n;++i){ // for letter for(int j=1;j&lt;=n;++j){ // for number if(judge(j,i)){ // build an edge, number points to letter e[j][i]=1;// printf(\"%c %d\\n\",i+64,j); out[j]++; // number's outdegree ++ } } } for(int i=1;i&lt;=n;++i){ if(out[i]==1){// printf(\"%d\\n\",i); q.push(i); } } int s=0; while(!q.empty()){ int v=q.front(); q.pop(); s++; int u; // letter for(int i=1;i&lt;=n;++i){ // record the path if(e[v][i]){ path[i]=v;// printf(\"%c %d\\n\",i+64,v); u=i; } } for(int i=1;i&lt;=n;++i){ if(e[i][u]){ out[i]--; // number's outdegree, i is a number if(out[i]==1) q.push(i); e[i][u]=0; // delete } } } if(s&lt;n){ // there's a circle cout&lt;&lt;\"None\"&lt;&lt;endl; return 0; } for(int i=1;i&lt;=s;++i) printf(\"%c %d\\n\",i+64,path[i]); return 0;}" }, { "title": "最小生成树", "url": "/posts/mst/", "categories": "图论, 算法", "tags": "图论", "date": "2019-01-19 16:52:19 +0800", "snippet": "定理的推论定理好像没什么用，主要是推论有用： 给定一张无向图 $G=(V,E)$ 其中 $n= V ，m= E $。从 $E$ 中选出 $k&lt;n-1$ 条边构成 $G$ 的一个生成森林。若再从剩余的 $m-k$ 条边中选 $n-1-k$ 条边添加到生成森林中，使起成为 $G$ 的生成树，并且选出的边的权值之后最小，则该生成树一定包含这 $m-k$ 条边中连接生成森林的两个不连通结点的权值最小的边。 这就暗示了，最小生成树一定含有两个结点间权值最小的边。这也因此使得下面的两种算法奏效。Prim算法#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 9010#define INF 1e8using namespace std;int n,m;int e[MAXN][MAXN],d[MAXN],visited[MAXN];void Prim(){ for(int i=1;i&lt;=n;++i){ d[i]=INF; visited[i]=0; } d[1]=0; for(int i=1;i&lt;n;++i){ int x=0; for(int j=1;j&lt;=n;++j) if(!visited[j]&amp;&amp;(x==0||d[j]&lt;d[x])) x=j; visited[x]=1; for(int y=1;y&lt;=n;++y) if(!visited[y]) d[y]=min(d[y],e[x][y]); } return;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) e[i][j]=i==j?0:INF; int u,v,w; for(int i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); e[u][v]=e[v][u]=w; } Prim(); int ans=0; for(int i=2;i&lt;=n;++i){ ans+=d[i]; } printf(\"%d\",ans); return 0;}这个写法我看了两天才看懂（我太菜了），下面给出一种可能会帮助理解的代码：（打印变量的值）#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAXN 9010#define INF 1e8using namespace std;int n,m;int e[MAXN][MAXN],d[MAXN],visited[MAXN];void Prim(){ for(int i=1;i&lt;=n;++i){ d[i]=INF; visited[i]=0; } d[1]=0; for(int i=1;i&lt;n;++i){ cout&lt;&lt;\"i=\"&lt;&lt;i&lt;&lt;\": \"&lt;&lt;endl; int x=0; for(int j=1;j&lt;=n;++j){ if(!visited[j]&amp;&amp;(x==0||d[j]&lt;d[x])) x=j; cout&lt;&lt;\"j=\"&lt;&lt;j&lt;&lt;\": \"&lt;&lt;\"x=\"&lt;&lt;x&lt;&lt;endl; } visited[x]=1; for(int y=1;y&lt;=n;++y){ // 更新不在生成树中的点到生成树的最小距离 if(!visited[y]) { d[y]=min(d[y],e[x][y]); cout&lt;&lt;\"y=\"&lt;&lt;y&lt;&lt;\" d[y]=\"&lt;&lt;d[y]&lt;&lt;endl; } } cout&lt;&lt;endl; } return;}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) e[i][j]=i==j?0:INF; int u,v,w; for(int i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); e[u][v]=e[v][u]=w; } Prim(); int ans=0; for(int i=2;i&lt;=n;++i){ ans+=d[i]; } printf(\"%d\",ans); return 0;}Kruskal算法#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#define MAXN 101#define MAXM 301using namespace std;int fa[MAXN];int find(int x){ if(x!=fa[x]) fa[x]=find(fa[x]); return fa[x];}struct node{ int u,v,w;}e[MAXM];int n,m;int d[MAXN],path[MAXN]; //path records the number it passesbool cmp(const node &amp;a,const node &amp;b){ return a.w&lt;b.w; }int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) fa[i]=i; for(int i=1;i&lt;=m;++i) scanf(\"%d%d%d\",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w); sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=n;++i) // at first each node is a set fa[i]=i; int k=0,ans=0; for(int i=1;i&lt;=m;++i){ if(find(e[i].u)!=find(e[i].v)){ d[++k]=e[i].w; path[k]=i; ans+=e[i].w; fa[find(e[i].u)]=find(e[i].v); } else{ continue; } } printf(\"%d\\n\",ans); for(int i=1;i&lt;=k;++i){ printf(\"%d %d\\n\",e[path[i]].u,e[path[i]].v); } return 0;}" }, { "title": "P1525 关押罪犯", "url": "/posts/P1525/", "categories": "题解", "tags": "并查集", "date": "2019-01-19 15:10:32 +0800", "snippet": "传送门分析基本思想就是：敌人的敌人是朋友题中说道把犯人们分成两部分，因此需要建立两个集合(并查集)。首先按危险程度降序排序，最高的那两个肯定要分开。于是就有如下情况：1° 两人是朋友关系。那么没有关系，放在一个集合里。(father相同)2° 两人是仇人关系。直接输出怨气值，并退出程序。3° 直到最后都没有找到。直接“0”。Code#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define M 100010#define N 20010using namespace std;inline int read(){ int f=1,x=0; static char c; c=getchar(); while(c&lt;'0'||c&gt;'9'){ if(c=='-') f=-1; c=getchar(); } while(c&gt;='0'&amp;&amp;c&lt;='9'){ x=x*10+c-'0'; c=getchar(); } return x*f;}int fa[N],enemy[N];int find(int x){ if(x!=fa[x]) fa[x]=find(fa[x]); return fa[x];}struct node{ int u,v,w;}e[M];bool cmp(const node &amp;a,const node &amp;b){ return a.w&gt;b.w;}int n,m;int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i){ fa[i]=i; enemy[i]=0; } for(int i=1;i&lt;=m;++i){ e[i].u=read();e[i].v=read();e[i].w=read(); } sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;++i){ int x=e[i].u,y=e[i].v; int f1=find(x),f2=find(y); if(f1!=f2){ if(enemy[x]==0) enemy[x]=y; if(enemy[y]==0) enemy[y]=x; // enemy's enemy is friend, put it into a set fa[find(x)]=fa[find(enemy[y])]; fa[find(y)]=fa[find(enemy[x])]; } else{ printf(\"%d\",e[i].w); return 0; } } printf(\"0\"); return 0;}" }, { "title": "OS X下利用shell脚本在Terminal中直接编译运行cpp文件", "url": "/posts/os-x-shell-run-cpp/", "categories": "实用", "tags": "", "date": "2019-01-12 19:20:24 +0800", "snippet": "每次用Terminal运行cpp文件是总是麻烦地重复输入 g++ -o name name.cpp 以至于引起不适（比如昨天调试 gcd() 时），于是学了一下shell脚本，发现是真的方便。操作方法1.打开Terminal2.输入 vi name.sh ，来创建一个脚本3.输入以下代码：#!/bin/bashread namecd 文件目录g++ -o ${name} ${name}.cpp./${name}代码解释 第二行读入文件名字 请将默认保存cpp文件的地址替换掉“文件目录” 下面几行自动输入指令4.输入 :wq 以保存并退出5.执行时，输入 . .\\name.sh （注意.之间有空格）6.输入cpp文件名（不用输入.cpp），回车7.Enjoy it！" }, { "title": "输入优化", "url": "/posts/fast-read/", "categories": "技巧", "tags": "", "date": "2018-12-30 15:52:35 +0800", "snippet": "在读入大量数据时，就连用scanf()都有可能被卡时间，于是有了下面这一串代码：Codeinline int read(){\tint x=0,f=1; //f判断正负，x记录数字\tchar ch=getchar();\twhile(ch&lt;'0'||ch&gt;'9'){\t\tif(ch=='-')\t\t\tf=-1;\t\tch=getchar();\t}\twhile(ch&gt;='0'&amp;&amp;ch&lt;='9'){\t\tx=x*10+ch-'0';\t\tch=getchar();\t}\treturn f*x;}当然，这个代码任有可以优化的地方即上述代码中的 x=x*10+ch-'0'，可以修改为 x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-'0'" }, { "title": "并查集", "url": "/posts/P1236/", "categories": "数据结构", "tags": "并查集", "date": "2018-12-30 15:15:22 +0800", "snippet": "以一道题展开吧……一本通P1346题目描述或许你并不知道，你的某个朋友是你的亲戚。他可能是你的曾祖父的外公的女婿的外甥女的表姐的孙子。如果能得到完整的家谱，判断两个人是否是亲戚应该是可行的，但如果两个人的最近公共祖先与他们相隔好几代，使得家谱十分庞大，那么检验亲戚关系实非人力所能及。在这种情况下，最好的帮手就是计算机。为了将问题简化，你将得到一些亲戚关系的信息，如Marry和Tom是亲戚，Tom和Ben是亲戚，等等。从这些信息中，你可以推出Marry和Ben是亲戚。请写一个程序，对于我们的关于亲戚关系的提问，以最快的速度给出答案。输入输入由两部分组成。第一部分以 $N,M$ 开始。$N$ 为问题涉及的人的个数( $1≤N≤20000$ )。这些人的编号为 $1,2,3,…,N$。下面有 $M$ 行( $1≤M≤1000000$ )，每行有两个数 $a_i,b_i$，表示已知 $a_i$ 和 $b_i$ 是亲戚。第二部分以 $Q$ 开始。以下 $Q$ 行有 $Q$ 个询问( $1≤ Q ≤1000000$ )，每行为$c_i,d_i$，表示询问 $c_i$ 和 $d_i$ 是否为亲戚。输出对于每个询问 $c_i,d_i$，输出一行：若 $c_i$ 和 $d_i$ 为亲戚，则输出“Yes”，否则输出“No”。输入样例10 72 45 71 38 91 25 62 333 47 108 9输出样例YesNoYes标准代码#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 1000001using namespace std;int father[MAXN];int n,m;int find_father(int x){ if(x!=father[x]) father[x]=find_father(father[x]); return father[x];}void set_union(int x,int y){ int x1=find_father(x); int y1=find_father(y); if(x1!=y1){ father[y1]=x1; }}int main(){ int a,b; scanf(\"%d%d\",&amp;n,&amp;m); /*************初始化************/ for(int i=1;i&lt;=n;++i) father[i]=i; for(int i=1;i&lt;=m;++i){ scanf(\"%d%d\",&amp;a,&amp;b); set_union(a,b); } int c,d,q; scanf(\"%d\",&amp;q); while(q--){ scanf(\"%d%d\",&amp;c,&amp;d); if(find_father(c)==find_father(d)) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0;}测试结果如下：我们来看一下测试数据：二十多mb的数据，scanf()哭死了，于是我又开启了我的输入优化之旅；优化之后" }, { "title": "图中的最短路径", "url": "/posts/shortest-path/", "categories": "图论, 算法", "tags": "图论", "date": "2018-12-23 14:47:16 +0800", "snippet": "Floyd算法可求多源最短路径。基本思想 DP 设 $d[i][j][k]$ 表示从 $i$ 到 $j$ 的路径中，经过的点的编号不超过 $k$ 的最短路。 边界条件 $d[i][j][0] = dis[i][j],d[i][i]=0$, 余下 $d[i][j]= \\mathrm{INF}$; 转移方程:\\[d[i][j][k] = \\min(d[i][j][k-1],d[i][k][k-1]+d[k][j][k-1]) (0&lt;k,0\\leqslant i,j\\leqslant n)\\]则 $dp[i][j][n]$ 即为所求代码$\\mathcal{O}(n^3)$for(k=1;k&lt;=n;++k) for(i=1;i&lt;=n;++i) for(j=1;j&lt;=n;++j) if(d[i][j]&gt;d[i][k]+d[k][j]) d[i][j]=d[i][k]+d[k][j];Dijsktra算法松弛松弛操作D[i]表示源点s到i的当前最短路径 条件：d[i]+e[i][j]&lt;d[j] 更新：d[j]=d[i]+e[i][j] 基本思想 这是一个贪心算法。 算法初始时d[s]=0，其余的点的d[]值为INF。有S、T两个集合，S集合中包含所有已求得最短路的点，T集合包含未求得最短路的点。 当T集合非空时，从T集合中选取d[]值最小的一个点，如果该点的d[] !=INF，则把它放入S集合，此时d[]值就是该点的最短路值。 当T集合为空或从T中选出的点的d[]==INF时，算法结束。朴素版伪代码复杂度 $\\mathcal{O}(n^2)$void dijkstra(int s,int t) { 初始化S={空集}, T=全集-S; d[s] = 0; 其余d值为INF while (T非空 &amp;&amp; T中最小的d[] != INF) { 取出T中具有最小d[]的点i; for (所有不在S中且与i相邻的点j) if (d[j] &gt; d[i] + cost[i][j]) d[j] = d[i] + cost[i][j]; ( “松弛”操作” ) S = S + {i}; //把i点添加到集合S里 T = T – {i}; } return;}说明 每次选取的j使d[]最小，这样可以保证它的路径已经是最短路。因为如果经过某个未标记点p到达j会产生更短的路，那么到达j的最短路长度必然要加上一个更大的d[p]，矛盾 d[k]=min{d[k],d[j]+cost[j][k]}的作用是在标记j以后更新d[]数组（松弛操作） 每次循环会对1个点进行标记，所以n-1次循环后所有点都做标记，d[]的含义变成可以经过所有点的最短距离，就是我们要的最短距离 如果找到的d[]最小的一个是d[]=INF，则可以提前结束循环，未做标记的点都是不可到达的 不能处理负权值边##朴素版代码(邻接矩阵)#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 10000#define INF 9999999using namespace std;int edge[MAXN][MAXN];// dist[]表示从原点到i的最小距离，abandoned[]表示是否访问过// path[]表示前驱点，用于输出路径 int dist[MAXN],path[MAXN],abandoned[MAXN];int m,n;void all_reset(int n){ // 不要用 memset()初始化为INF for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) edge[i][j]=(i==j)?0:INF; return;}void reset(int n){ for(int i=1;i&lt;=n;++i){ dist[i]=INF; abandoned[i]=0; path[i]=-1; } return;}void Dijsktra(int s){ // 初始化 reset(n); dist[s]=0; for(int i=1;i&lt;=n;++i){ // 外层循环用来遍历所有点 int min=INF; int w; for(int j=1;j&lt;=n;++j) // 贪心部分，寻找最短距离的点（向外扩张） if(!abandoned[j] &amp;&amp; dist[j]&lt;min){ min=dist[j]; w=j; } // 找到了，标记一下 abandoned[w]=1; for(int v=1;v&lt;=n;++v){ // 寻找下一条边 if(dist[v]&gt;dist[w]+edge[w][v]) dist[v]=dist[w]+edge[w][v]; path[v]=w; } } return;}int main(){ int u,v,d; scanf(\"%d%d\",&amp;n,&amp;m); // 初始化边 all_reset(n); // 读入边 for(int i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;d); edge[u][v]=d; } Dijsktra(1); // 打印dist[]数组 for(int i=1;i&lt;=n;++i){ printf(\"dist[%d]=%d\\n\",i,dist[i]); } return 0;}优先队列优化使用结构体的成员函数和运算符重载以及优先队列，复杂度 $\\mathcal{O}(n\\lg n)$结构体的定义：struct node{ int u,d; node(){}; node(int a, int b){ u=a;d=b; } bool operator &lt; (const node&amp; a)const{ return d&gt;a.d; }};代码解释： 赋值更简单赋值可以直接写为node t(1,2)，等价于t.u=1;t.d=2 适配了优先队列 因为定义了&lt;，使得优先队列可以运行优先队列+邻接矩阵代码#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#define MAXN 10001#define INF 2e8using namespace std;int g[MAXN][MAXN],d[MAXN],path[MAXN];bool abandoned[MAXN];int n,m;struct node{ int u,d; // 源点到u的最短路径d node(){}; node(int a, int b){ //赋值函数，用法:node 变量名(参数1,参数2) u=a;d=b; } bool operator &lt; (const node&amp; a)const{ //重载&lt; return d&gt;a.d; }};void Dijsktra(int s){ priority_queue &lt;node&gt; q; // 定义一个node型的优先队列 /*======初始化======*/ q.push(node(s,0)); memset(abandoned,0,sizeof(abandoned)); memset(path,-1,sizeof(path)); for(int i=1;i&lt;=n;++i){ d[i]=INF; } d[s]=0; while(!q.empty()){ node x=q.top(); q.pop(); int u=x.u; if(abandoned[u]) continue; // 找到最短路径，因为队列中有重复元素 abandoned[u]=1; for(int v=1;v&lt;=n;++v){ if(!abandoned[v] &amp;&amp; g[u][v]&lt;INF){ //找相邻的节点 if(d[v]&gt;d[u]+g[u][v]){ //松弛操作 d[v]=d[u]+g[u][v]; q.push(node(v,d[v])); } } } } return; }int main(){ int u,v,w,s; scanf(\"%d%d\",&amp;n,&amp;m); /*=======初始化=======*/ for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) g[i][j]=(i==j)?0:INF; /*=======读入=========*/ for(int i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); g[u][v]=w; } scanf(\"%d\",&amp;s); Dijsktra(s); /*======输出到所有结点的最短路径长度======*/ for(int i=1;i&lt;=n;++i){ printf(\"%d -&gt; %d: \",s,i); if(d[i]==INF){ printf(\"INF\\n\"); } else{ printf(\"%d\\n\",d[i]); } } return 0;}SPFAFord算法的优化，时间复杂度小于等于 $\\mathcal{O}(NE)$（吧？？）伪代码：void SPFA(int s){ //初始化 d[]=INF; pushed[]=0; d[s]=0; q.push(s); pushed[s]=1; while(!q.empty()){ u=q.front(); q.pop(); pushed[u]=0; for(v=起点为u的边的终点){ // 注意穷举的是边 if(d[edge[v].v]&gt;edge[v].w+d[u]){ d[edge[v].v]=edge[v].w+d[u]; q.push(edge[v].v); } } }}具体应用一本通P1382#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;#define INF 1e7#define MAXN 1000010using namespace std;queue &lt;int&gt; q;int n,m;struct myType{ int u,v; int w; int next;}edge[MAXN];int head[MAXN];int k;void add(int u,int v,int w){ k++; edge[k].next=head[u]; head[u]=k; edge[k].u=u;edge[k].v=v;edge[k].w=w; return;}int d[MAXN];int path[MAXN];bool pushed[MAXN];void SPFA(){ /* =======初始化======= */ for(int i=1;i&lt;=n;++i) d[i]=INF; d[1]=0; //源点为0; memset(pushed,0,sizeof(pushed)); q.push(1); pushed[1]=1; while(!q.empty()){ int u=q.front(); q.pop(); pushed[u]=0; for(int v=head[u];v!=-1;v=edge[v].next){ if(d[edge[v].v]&gt;edge[v].w+d[u]){ d[edge[v].v]=edge[v].w+d[u]; q.push(edge[v].v); } } } return;}int main(){ memset(head,-1,sizeof(head)); k=0; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); } SPFA(); printf(\"%d\",d[n]); return 0;}最短路径中的一些重要性质三角不等式对任意边 $\\text{&lt;}u,v\\text{&gt;}\\in E$，有$\\delta(s,v)\\leq \\delta(s,u)+w(u,v)$上界性质对于任意顶点 $u\\in V$，有$d[v]\\geq \\delta(s.v)$，而且一旦 $d[v]$ 到达，$\\delta(s,v)$ 就不再改变。无路径性质如果从 $s$ 到 $v$ 不存在路径，则总是有 $d[v]=\\delta(s,v)=\\infty$收敛性质如果 $s\\leadsto u\\rightarrow v$ 是图 $G$ 某 $u,v\\in V$ 的最短路径，而且在松弛边 $\\text{&lt;}u,v\\text{&gt;}$ 之前的任意时间 $d[u]=\\delta(s,u)$，则在操作之后总有 $d[v]=\\delta(s,v)$路径松弛性质如果 $p=\\text{&lt;}v_0,v_1,\\ldots ,v_k\\text{&gt;}$ 是从 $s=v_0$ 到 $v_k$ 的最短路径，而且 $p$ 的边按照 $(v_0,v_1)(v_1,v_2),\\ldots,(v_{k-1},v_k)$ 的顺序进行松弛，那么 $d[v_k]=\\delta(s,v_k)$。这个性质的保持并不受其他松弛操作的影响，即使它们与 $p$ 边上的松弛操作是混合在一起也是一样的。前驱子图性质一旦对于所有 $v\\in V,d[v]=\\delta(s,v)$，前驱子图就是一个以 $s$ 为根的最短路径树。" }, { "title": "图", "url": "/posts/graph/", "categories": "图论, 算法, 数据结构", "tags": "图论", "date": "2018-12-15 20:53:37 +0800", "snippet": "G V E规定：用 $G = (V,E)$ 来表示一个图。其中 $V$ 是所有顶点（Vertex）的集合， $E$ 是所有边（Edge）的集合；图的表示邻接矩阵用 G[N][N] 表示顶点 0 到 N-1 的编号\\[G[i][j]=\\begin{cases}1,\\ \\mathrm{if} \\ \\mathrm{&lt;}v_i,v_j\\mathrm{&gt;} \\in E\\\\0,\\ \\mathrm{otherwise} \\\\end{cases}\\]不难发现矩阵是关于中间的红线对称的那么这样储存将极大地浪费空间，于是可以用一位数组来储存下半部分，只需变换一下下标即可。定义一个数组 G[N(N+1)/2] ，那么 $G_{ij}$ 的下标就是\\(\\frac{i\\cdot(i+1)}{2}+j\\)若为网络，则把 G[i][j] 定义为 $\\mathrm{&lt;}v_i,v_j\\mathrm{&gt;}$ 的权重即可看着玩的一种表示方法：图的邻接矩阵表示法#define MaxVertexNum 100 /* 最大顶点数设为100 */#define INFINITY 65535 /* ∞设为双字节无符号整数的最大值65535*/typedef int Vertex; /* 用顶点下标表示顶点,为整型 */typedef int WeightType; /* 边的权值设为整型 */typedef char DataType; /* 顶点存储的数据类型设为字符型 */ /* 边的定义 */typedef struct ENode *PtrToENode;struct ENode{ Vertex V1, V2; /* 有向边&lt;V1, V2&gt; */ WeightType Weight; /* 权重 */};typedef PtrToENode Edge; /* 图结点的定义 */typedef struct GNode *PtrToGNode;struct GNode{ int Nv; /* 顶点数 */ int Ne; /* 边数 */ WeightType G[MaxVertexNum][MaxVertexNum]; /* 邻接矩阵 */ DataType Data[MaxVertexNum]; /* 存顶点的数据 */ /* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */};typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */ MGraph CreateGraph( int VertexNum ){ /* 初始化一个有VertexNum个顶点但没有边的图 */ Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); /* 建立图 */ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /* 初始化邻接矩阵 */ /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) for (W=0; W&lt;Graph-&gt;Nv; W++) Graph-&gt;G[V][W] = INFINITY; return Graph; } void InsertEdge( MGraph Graph, Edge E ){ /* 插入边 &lt;V1, V2&gt; */ Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight; /* 若是无向图，还要插入边&lt;V2, V1&gt; */ Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;} MGraph BuildGraph(){ MGraph Graph; Edge E; Vertex V; int Nv, i; scanf(\"%d\", &amp;Nv); /* 读入顶点个数 */ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf(\"%d\", &amp;(Graph-&gt;Ne)); /* 读入边数 */ if ( Graph-&gt;Ne != 0 ) { /* 如果有边 */ E = (Edge)malloc(sizeof(struct ENode)); /* 建立边结点 */ /* 读入边，格式为\"起点 终点 权重\"，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) { scanf(\"%d %d %d\", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); } } /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(\" %c\", &amp;(Graph-&gt;Data[V])); return Graph;}稠密图优先使用邻接矩阵邻接表G[N] 为指针数组对应矩阵每一行一个链表，只存非0元素对于网络，结构中要增加权重的域邻接表特点： 方便找任一顶点的所有“邻接点” 节约稀疏图的空间需要N个头指针 + 2E个结点(每个结点至少2个域) 方便计算任一顶点的“度”?对无向图:是的对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己 的边)来方便计算“入度” 方便检查任意一对顶点间是否存在边? 不方便 数组模拟链表#include&lt;cstdio&gt;#include&lt;cstring&gt;#define MAXN 10000using namespace std;int k;struct mytype{ int u,v; //从u到v的一条边 int w; //权重 int next; //指向下一条边 }edge[MAXN];int head[MAXN]; //head[i]表示以顶点i起始的链表，指向最后插入的边 void add(int u,int v,int w){ ++k; edge[k].next=head[u]; head[u]=k; edge[k].u=u;edge[k].v=v;edge[k].w=w; return;}int main(){ memset(head,-1,sizeof(head)); k=0; int n,m; int u,v,w; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;++i){ scanf(\"%d%d%d\",&amp;u,&amp;v,&amp;w); add(u,v,w); // 若为无向图 // 则加上一句 add(v,u,w); } /*=========链表的输出=========*/ for(int i=1;i&lt;=n;++i){ // 穷举所有顶点 printf(\"%d:\",i); for(int j=head[i];j!=-1;j=edge[j].next){ printf(\" %d\",edge[j].v); } printf(\"\\n\"); } return 0;}图的邻接表表示法#define MaxVertexNum 100 /* 最大顶点数设为100 */typedef int Vertex; /* 用顶点下标表示顶点,为整型 */typedef int WeightType; /* 边的权值设为整型 */typedef char DataType; /* 顶点存储的数据类型设为字符型 */ /* 边的定义 */typedef struct ENode *PtrToENode;struct ENode{ Vertex V1, V2; /* 有向边&lt;V1, V2&gt; */ WeightType Weight; /* 权重 */};typedef PtrToENode Edge; /* 邻接点的定义 */typedef struct AdjVNode *PtrToAdjVNode; struct AdjVNode{ Vertex AdjV; /* 邻接点下标 */ WeightType Weight; /* 边权重 */ PtrToAdjVNode Next; /* 指向下一个邻接点的指针 */}; /* 顶点表头结点的定义 */typedef struct Vnode{ PtrToAdjVNode FirstEdge;/* 边表头指针 */ DataType Data; /* 存顶点的数据 */ /* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */} AdjList[MaxVertexNum]; /* AdjList是邻接表类型 */ /* 图结点的定义 */typedef struct GNode *PtrToGNode;struct GNode{ int Nv; /* 顶点数 */ int Ne; /* 边数 */ AdjList G; /* 邻接表 */};typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */ LGraph CreateGraph( int VertexNum ){ /* 初始化一个有VertexNum个顶点但没有边的图 */ Vertex V; LGraph Graph; Graph = (LGraph)malloc( sizeof(struct GNode) ); /* 建立图 */ Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; /* 初始化邻接表头指针 */ /* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) */ for (V=0; V&lt;Graph-&gt;Nv; V++) Graph-&gt;G[V].FirstEdge = NULL; return Graph; } void InsertEdge( LGraph Graph, Edge E ){ PtrToAdjVNode NewNode; /* 插入边 &lt;V1, V2&gt; */ /* 为V2建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; /* 将V2插入V1的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; /* 若是无向图，还要插入边 &lt;V2, V1&gt; */ /* 为V1建立新的邻接点 */ NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; /* 将V1插入V2的表头 */ NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;} LGraph BuildGraph(){ LGraph Graph; Edge E; Vertex V; int Nv, i; scanf(\"%d\", &amp;Nv); /* 读入顶点个数 */ Graph = CreateGraph(Nv); /* 初始化有Nv个顶点但没有边的图 */ scanf(\"%d\", &amp;(Graph-&gt;Ne)); /* 读入边数 */ if ( Graph-&gt;Ne != 0 ) { /* 如果有边 */ E = (Edge)malloc( sizeof(struct ENode) ); /* 建立边结点 */ /* 读入边，格式为\"起点 终点 权重\"，插入邻接矩阵 */ for (i=0; i&lt;Graph-&gt;Ne; i++) { scanf(\"%d %d %d\", &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); /* 注意：如果权重不是整型，Weight的读入格式要改 */ InsertEdge( Graph, E ); } } /* 如果顶点有数据的话，读入数据 */ for (V=0; V&lt;Graph-&gt;Nv; V++) scanf(\" %c\", &amp;(Graph-&gt;G[V].Data)); return Graph;}DFSvoid DFS(Vertex V){ visited[V]=true; for(V的每个邻接点W) if(!visited[W]) DFS(W);}若有 $N$ 个顶点、$E$ 条边，时间复杂度是:用邻接表存储图，有 $\\mathcal{O}(N+E)$用邻接矩阵存储图，有 $\\mathcal{O}(N^2)$邻接表存储的图 - DFSvoid Visit( Vertex V ){ printf(\"正在访问顶点%d\\n\", V);} /* Visited[]为全局变量，已经初始化为false */void DFS( LGraph Graph, Vertex V, void (*Visit)(Vertex) ){ /* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */ PtrToAdjVNode W; Visit( V ); /* 访问第V个顶点 */ Visited[V] = true; /* 标记V已访问 */ for( W=Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next ) /* 对V的每个邻接点W-&gt;AdjV */ if ( !Visited[W-&gt;AdjV] ) /* 若W-&gt;AdjV未被访问 */ DFS( Graph, W-&gt;AdjV, Visit ); /* 则递归访问之 */}BFSvoid BFS(Vertex V){ visited[v]=true; q.push(V); while(!q.empty()){ V=q.top(); q.pop(); for(V的每一个邻接点W){ if(!visited[W]){ visited[W]=true; q.push(W); } } }}若有 $N$ 个顶点、$E$ 条边，时间复杂度是:用邻接表存储图，有 $\\mathcal{O}(N+E)$用邻接矩阵存储图，有 $\\mathcal{O}(N^2)$/* 邻接矩阵存储的图 - BFS */ /* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。 *//* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*//* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下: */bool IsEdge( MGraph Graph, Vertex V, Vertex W ){ return Graph-&gt;G[V][W]&lt;INFINITY ? true : false;} /* Visited[]为全局变量，已经初始化为false */void BFS ( MGraph Graph, Vertex S, void (*Visit)(Vertex) ){ /* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */ Queue Q; Vertex V, W; Q = CreateQueue( MaxSize ); /* 创建空队列, MaxSize为外部定义的常数 */ /* 访问顶点S：此处可根据具体访问需要改写 */ Visit( S ); Visited[S] = true; /* 标记S已访问 */ AddQ(Q, S); /* S入队列 */ while ( !IsEmpty(Q) ) { V = DeleteQ(Q); /* 弹出V */ for( W=0; W&lt;Graph-&gt;Nv; W++ ) /* 对图中的每个顶点W */ /* 若W是V的邻接点并且未访问过 */ if ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) { /* 访问顶点W */ Visit( W ); Visited[W] = true; /* 标记W已访问 */ AddQ(Q, W); /* W入队列 */ } } /* while结束*/}一堆概念连通:如果从 V 到 W 存在一条(无向)路径，则称 V 和 W 是连通的路径: V 到 W 的路径是一系列顶点 {V, v1, v2, ..., vn,W} 的集合，其中任一对相邻的顶点间都有图中的边。路径的长度是路径中的边数(如果带权，则是所有边的权重和)。如果 V 到 W 之间的所有顶点都不同，则称简单路径回路:起点等于终点的路径连通图:图中任意两顶点均连通连通分量:无向图的极大连通子图极大顶点数:再加1个顶点就不连通了极大边数:包含子图中所有顶点相连的所有边强连通:有向图中顶点 V 和 W 之间存在双向路径，则称 V 和 W 是强连通的强连通图:有向图中任意两顶点均强连通强连通分量:有向图的极大强连通子图图不连通时…用一个函数列举出所有分量，如果没有访问过，搜索这个分量Cvoid listComponents(Graph G){ for(所有G中的V) if(!visited[V]){ DFS(V); // BFS(V); }}" }, { "title": "打表", "url": "/posts/dabiao/", "categories": "技巧", "tags": "打表", "date": "2018-12-09 16:28:45 +0800", "snippet": "分块打表单身数 dhy认为符合以下条件的数非常不吉利，会导致单身。单身数是这样定义的： 一个数x为单生数，当且仅当这个数中数字1的个数不小于这个数位数的50%由于dhy长期单身，所以他非常讨厌单身数。他想知道区间[l,r]之间有多少个单身数。由于dhy实在是太垃圾了，于是他把问题交给了zyc,但是这个世界总是充满了但是，zyc正忙着花式AK IOI，根本没空搭理垃圾的dhy，于是他把问题交给了聪明的你，如果你能再规定时间内给dhy正确的答案，那么zyc会奖励你10分，如果你没能完成任务,zyc会非常不开心，那么你就没分了。 输入样例11 10 输出样例2 //1和10分块打表主要思路1 在本机写程序打出blocklength范围内的表格(注意长度)2 将表格输入源程序3 分段处理，结合前置和。于是这道题就可以这样写：打表程序#pragma GCC optimize(\"Ofast\") //O2优化加速#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;fstream&gt; //打表数据输入输出所需要的库#include&lt;cstdlib&gt;using namespace std;bool judge(int x){ //判断函数 int count=0,length=0; while(x&gt;0){ if(x%10==1) count++; x/=10; length++; } if((double)count/(double)length&gt;=0.5)return true; return false;}int main(){ ofstream out(\"data.out\"); int count=0; int round=0; //记录轮数 for(int i=1;i&lt;=2e8;++i){ if(judge(i)){ count++; } round++; if(round==100000){ //满一块(即blocklength) round=0; out&lt;&lt;count&lt;&lt;\",\"; printf(\"%.2lf\\n\",(double)i/(double)2e8); // 用于在屏幕输入输出进度 } } out.close(); return 0;}然后打出表格复制到源程序源程序#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;int table[200000]={1360,9506,10362,11218,12074,12930,13786,14642,15498,16354,17210,25356,26212,27068,27924,28780,29636,30492,31348,32204,32250,33106,33152,33198,33244,33290,33336,33382,33428,33474,33520,34376,34422,34468,34514,34560,34606,34652,34698,34744,34790,35646,35692,35738,35784,35830,35876,35922,35968,36014,36060,36916,36962,37008,37054,37100,37146,37192,37238,37284,37330,38186,38232,38278,38324,38370,38416,38462,38508,38554,38600,39456,39502,39548,39594,39640,39686,39732,39778,39824,39870,40726,40772,40818,40864,40910,40956,41002,41048,41094,41140,41996,42042,42088,42134,42180,42226,42272,42318,42364,43220,51366,52222,53078,53934,54790,55646,56502,57358,58214,66360,107311,115457,123603,131749,139895,148041,156187,164333,172479,173335,181481,182337,183193,184049,184905,185761,186617,187473,188329,189185,197331,198187,199043,199899,200755,201611,202467,203323,204179,205035,213181,214037,214893,215749,216605,217461,218317,219173,220029,220885,229031,229887,230743,231599,232455,233311,234167,235023,235879,236735,244881,245737,246593,247449,248305,249161,250017,250873,251729,252585,260731,261587,262443,263299,264155,265011,265867,266723,267579,268435,276581,277437,278293,279149,280005,280861,281717,282573,283429,284285,292431,293287,294143,294999,295855,296711,297567,298423,299279,299325,300181,300227,300273,300319,300365,300411,300457,300503,300549,301405,309551,310407,311263,312119,312975,313831,314687,315543,316399,316445,317301,317347,317393,317439,317485,317531,317577,317623,317669,317715,318571,318617,318663,318709,318755,318801,318847,318893,318939,318985,319841,319887,319933,319979,320025,320071,320117,320163,320209,320255,321111,321157,321203,321249,321295,321341,321387,321433,321479,321525,322381,322427,322473,322519,322565,322611,322657,322703,322749,322795,323651,323697,323743,323789,323835,323881,323927,323973,324019,324065,324921,324967,325013,325059,325105,325151,325197,325243,325289,325335,326191,326237,326283,326329,326375,326421,326467,326513,326559,326605,327461,327507,327553,327599,327645,327691,327737,327783,327829,328685,336831,337687,338543,339399,340255,341111,341967,342823,343679,343725,344581,344627,344673,344719,344765,344811,344857,344903,344949,344995,345851,345897,345943,345989,346035,346081,346127,346173,346219,346265,347121,347167,347213,347259,347305,347351,347397,347443,347489,347535,348391,348437,348483,348529,348575,348621,348667,348713,348759,348805,349661,349707,349753,349799,349845,349891,349937,349983,350029,350075,350931,350977,351023,351069,351115,351161,351207,351253,351299,351345,352201,352247,352293,352339,352385,352431,352477,352523,352569,352615,353471,353517,353563,353609,353655,353701,353747,353793,353839,353885,354741,354787,354833,354879,354925,354971,355017,355063,355109,355965,364111,364967,365823,366679,367535,368391,369247,370103,370959,371005,371861,371907,371953,371999,372045,372091,372137,372183,372229,372275,373131,373177,373223,373269,373315,373361,373407,373453,373499,373545,374401,374447,374493,374539,374585,374631,374677,374723,374769,374815,375671,375717,375763,375809,375855,375901,375947,375993,376039,376085,376941,376987,377033,377079,377125,377171,377217,377263,377309,377355,378211,378257,378303,378349,378395,378441,378487,378533,378579,378625,379481,379527,379573,379619,379665,379711,379757,379803,379849,379895,380751,380797,380843,380889,380935,380981,381027,381073,381119,381165,382021,382067,382113,382159,382205,382251,382297,382343,382389,383245,391391,392247,393103,393959,394815,395671,396527,397383,398239,398285,399141,399187,399233,399279,399325,399371,399417,399463,399509,399555,400411,400457,400503,400549,400595,400641,400687,400733,400779,400825,401681,401727,401773,401819,401865,401911,401957,402003,402049,402095,402951,402997,403043,403089,403135,403181,403227,403273,403319,403365,404221,404267,404313,404359,404405,404451,404497,404543,404589,404635,405491,405537,405583,405629,405675,405721,405767,405813,405859,405905,406761,406807,406853,406899,406945,406991,407037,407083,407129,407175,408031,408077,408123,408169,408215,408261,408307,408353,408399,408445,409301,409347,409393,409439,409485,409531,409577,409623,409669,410525,418671,419527,420383,421239,422095,422951,423807,424663,425519,425565,426421,426467,426513,426559,426605,426651,426697,426743,426789,426835,427691,427737,427783,427829,427875,427921,427967,428013,428059,428105,428961,429007,429053,429099,429145,429191,429237,429283,429329,429375,430231,430277,430323,430369,430415,430461,430507,430553,430599,430645,431501,431547,431593,431639,431685,431731,431777,431823,431869,431915,432771,432817,432863,432909,432955,433001,433047,433093,433139,433185,434041,434087,434133,434179,434225,434271,434317,434363,434409,434455,435311,435357,435403,435449,435495,435541,435587,435633,435679,435725,436581,436627,436673,436719,436765,436811,436857,436903,436949,437805,445951,446807,447663,448519,449375,450231,451087,451943,452799,452845,453701,453747,453793,453839,453885,453931,453977,454023,454069,454115,454971,455017,455063,455109,455155,455201,455247,455293,455339,455385,456241,456287,456333,456379,456425,456471,456517,456563,456609,456655,457511,457557,457603,457649,457695,457741,457787,457833,457879,457925,458781,458827,458873,458919,458965,459011,459057,459103,459149,459195,460051,460097,460143,460189,460235,460281,460327,460373,460419,460465,461321,461367,461413,461459,461505,461551,461597,461643,461689,461735,462591,462637,462683,462729,462775,462821,462867,462913,462959,463005,463861,463907,463953,463999,464045,464091,464137,464183,464229,465085,473231,474087,474943,475799,476655,477511,478367,479223,480079,480125,480981,481027,481073,481119,481165,481211,481257,481303,481349,481395,482251,482297,482343,482389,482435,482481,482527,482573,482619,482665,483521,483567,483613,483659,483705,483751,483797,483843,483889,483935,484791,484837,484883,484929,484975,485021,485067,485113,485159,485205,486061,486107,486153,486199,486245,486291,486337,486383,486429,486475,487331,487377,487423,487469,487515,487561,487607,487653,487699,487745,488601,488647,488693,488739,488785,488831,488877,488923,488969,489015,489871,489917,489963,490009,490055,490101,490147,490193,490239,490285,491141,491187,491233,491279,491325,491371,491417,491463,491509,492365,500511,501367,502223,503079,503935,504791,505647,506503,507359,507405,508261,508307,508353,508399,508445,508491,508537,508583,508629,508675,509531,509577,509623,509669,509715,509761,509807,509853,509899,509945,510801,510847,510893,510939,510985,511031,511077,511123,511169,511215,512071,512117,512163,512209,512255,512301,512347,512393,512439,512485,513341,513387,513433,513479,513525,513571,513617,513663,513709,513755,514611,514657,514703,514749,514795,514841,514887,514933,514979,515025,515881,515927,515973,516019,516065,516111,516157,516203,516249,516295,517151,517197,517243,517289,517335,517381,517427,517473,517519,517565,518421,518467,518513,518559,518605,518651,518697,518743,518789,519645,527791,528647,529503,530359,531215,532071,532927,533783,534639,534685,535541,535587,535633,535679,535725,535771,535817,535863,535909,535955,536811,536857,536903,536949,536995,537041,537087,537133,537179,537225,538081,538127,538173,538219,538265,538311,538357,538403,538449,538495,539351,539397,539443,539489,539535,539581,539627,539673,539719,539765,540621,540667,540713,540759,540805,540851,540897,540943,540989,541035,541891,541937,541983,542029,542075,542121,542167,542213,542259,542305,543161,543207,543253,543299,543345,543391,543437,543483,543529,543575,544431,544477,544523,544569,544615,544661,544707,544753,544799,545655,553801,554657,555513,556369,557225,558081,558937,559793,560649,568795,609746,617892,626038,634184,642330,650476,658622,666768,674914,675770,683916,684772,685628,686484,687340,688196,689052,689908,690764,691620,699766,700622,701478,702334,703190,704046,704902,705758,706614,707470,715616,716472,717328,718184,719040,719896,720752,721608,722464,723320,731466,732322,733178,734034,734890,735746,736602,737458,738314,739170,747316,748172,749028,749884,750740,751596,752452,753308,754164,755020,763166,764022,764878,765734,766590,767446,768302,769158,770014,770870,779016,779872,780728,781584,782440,783296,784152,785008,785864,786720,794866,795722,796578,797434,798290,799146,800002,800858,801714,801760,802616,802662,802708,802754,802800,802846,802892,802938,802984,803840,811986,812842,813698,814554,815410,816266,817122,817978,818834,818880,819736,819782,819828,819874,819920,819966,820012,820058,820104,820150,821006,821052,821098,821144,821190,821236,821282,821328,821374,821420,822276,822322,822368,822414,822460,822506,822552,822598,822644,822690,823546,823592,823638,823684,823730,823776,823822,823868,823914,823960,824816,824862,824908,824954,825000,825046,825092,825138,825184,825230,826086,826132,826178,826224,826270,826316,826362,826408,826454,826500,827356,827402,827448,827494,827540,827586,827632,827678,827724,827770,828626,828672,828718,828764,828810,828856,828902,828948,828994,829040,829896,829942,829988,830034,830080,830126,830172,830218,830264,831120,839266,840122,840978,841834,842690,843546,844402,845258,846114,846160,847016,847062,847108,847154,847200,847246,847292,847338,847384,847430,848286,848332,848378,848424,848470,848516,848562,848608,848654,848700,849556,849602,849648,849694,849740,849786,849832,849878,849924,849970,850826,850872,850918,850964,851010,851056,851102,851148,851194,851240,852096,852142,852188,852234,852280,852326,852372,852418,852464,852510,853366,853412,853458,853504,853550,853596,853642,853688,853734,853780,854636,854682,854728,854774,854820,854866,854912,854958,855004,855050,855906,855952,855998,856044,856090,856136,856182,856228,856274,856320,857176,857222,857268,857314,857360,857406,857452,857498,857544,858400,866546,867402,868258,869114,869970,870826,871682,872538,873394,873440,874296,874342,874388,874434,874480,874526,874572,874618,874664,874710,875566,875612,875658,875704,875750,875796,875842,875888,875934,875980,876836,876882,876928,876974,877020,877066,877112,877158,877204,877250,878106,878152,878198,878244,878290,878336,878382,878428,878474,878520,879376,879422,879468,879514,879560,879606,879652,879698,879744,879790,880646,880692,880738,880784,880830,880876,880922,880968,881014,881060,881916,881962,882008,882054,882100,882146,882192,882238,882284,882330,883186,883232,883278,883324,883370,883416,883462,883508,883554,883600,884456,884502,884548,884594,884640,884686,884732,884778,884824,885680,893826,894682,895538,896394,897250,898106,898962,899818,900674,900720,901576,901622,901668,901714,901760,901806,901852,901898,901944,901990,902846,902892,902938,902984,903030,903076,903122,903168,903214,903260,904116,904162,904208,904254,904300,904346,904392,904438,904484,904530,905386,905432,905478,905524,905570,905616,905662,905708,905754,905800,906656,906702,906748,906794,906840,906886,906932,906978,907024,907070,907926,907972,908018,908064,908110,908156,908202,908248,908294,908340,909196,909242,909288,909334,909380,909426,909472,909518,909564,909610,910466,910512,910558,910604,910650,910696,910742,910788,910834,910880,911736,911782,911828,911874,911920,911966,912012,912058,912104,912960,921106,921962,922818,923674,924530,925386,926242,927098,927954,928000,928856,928902,928948,928994,929040,929086,929132,929178,929224,929270,930126,930172,930218,930264,930310,930356,930402,930448,930494,930540,931396,931442,931488,931534,931580,931626,931672,931718,931764,931810,932666,932712,932758,932804,932850,932896,932942,932988,933034,933080,933936,933982,934028,934074,934120,934166,934212,934258,934304,934350,935206,935252,935298,935344,935390,935436,935482,935528,935574,935620,936476,936522,936568,936614,936660,936706,936752,936798,936844,936890,937746,937792,937838,937884,937930,937976,938022,938068,938114,938160,939016,939062,939108,939154,939200,939246,939292,939338,939384,940240,948386,949242,950098,950954,951810,952666,953522,954378,955234,955280,956136,956182,956228,956274,956320,956366,956412,956458,956504,956550,957406,957452,957498,957544,957590,957636,957682,957728,957774,957820,958676,958722,958768,958814,958860,958906,958952,958998,959044,959090,959946,959992,960038,960084,960130,960176,960222,960268,960314,960360,961216,961262,961308,961354,961400,961446,961492,961538,961584,961630,962486,962532,962578,962624,962670,962716,962762,962808,962854,962900,963756,963802,963848,963894,963940,963986,964032,964078,964124,964170,965026,965072,965118,965164,965210,965256,965302,965348,965394,965440,966296,966342,966388,966434,966480,966526,966572,966618,966664,967520,975666,976522,977378,978234,979090,979946,980802,981658,982514,982560,983416,983462,983508,983554,983600,983646,983692,983738,983784,983830,984686,984732,984778,984824,984870,984916,984962,985008,985054,985100,985956,986002,986048,986094,986140,986186,986232,986278,986324,986370,987226,987272,987318,987364,987410,987456,987502,987548,987594,987640,988496,988542,988588,988634,988680,988726,988772,988818,988864,988910,989766,989812,989858,989904,989950,989996,990042,990088,990134,990180,991036,991082,991128,991174,991220,991266,991312,991358,991404,991450,992306,992352,992398,992444,992490,992536,992582,992628,992674,992720,993576,993622,993668,993714,993760,993806,993852,993898,993944,994800,1002946,1003802,1004658,1005514,1006370,1007226,1008082,1008938,1009794,1009840,1010696,1010742,1010788,1010834,1010880,1010926,1010972,1011018,1011064,1011110,1011966,1012012,1012058,1012104,1012150,1012196,1012242,1012288,1012334,1012380,1013236,1013282,1013328,1013374,1013420,1013466,1013512,1013558,1013604,1013650,1014506,1014552,1014598,1014644,1014690,1014736,1014782,1014828,1014874,1014920,1015776,1015822,1015868,1015914,1015960,1016006,1016052,1016098,1016144,1016190,1017046,1017092,1017138,1017184,1017230,1017276,1017322,1017368,1017414,1017460,1018316,1018362,1018408,1018454,1018500,1018546,1018592,1018638,1018684,1018730,1019586,1019632,1019678,1019724,1019770,1019816,1019862,1019908,1019954}; //打出的表格，记得删掉最后一个逗号int blockLength=100000; //与打表程序一致 bool judge(int x){ //判断函数，与打表程序一致 int count=0,length=0; while(x&gt;0){ if(x%10==1) count++; x/=10; length++; } if((double)count/(double)length&gt;=0.5)return true; return false;}int solve(int l,int r){ int tl=l/blockLength; int tr=r/blockLength; // 其实这个&lt;=1的判断都不需要，后面也要计算，但是dhy大佬还是写了 if(tr-tl&lt;=1){ // 范围差距小 int count=0; for(int i=l;i&lt;=r;++i){ if(judge(i)) count++; } return count; } else{ int up=tr; int down=tl; int sum1=0,sum2=0; // 前置和 for(int i=down*blockLength+1;i&lt;=l-1;++i){ if(judge(i)) sum1++; } if(l&gt;=blockLength) sum1+=table[down-1]; //-1是因为从0计数 for(int i=up*blockLength+1;i&lt;=r;++i) if(judge(i)) sum2++; sum2+=table[up-1]; return sum2-sum1; }}int main(){ int n,a,b; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;++i){ scanf(\"%d%d\",&amp;a,&amp;b); printf(\"%d\\n\",solve(a,b)); } return 0;}dhy大佬手稿" }, { "title": "这是一个模板", "url": "/posts/this-is-a-template/", "categories": "模板", "tags": "博客模板", "date": "2000-01-01 00:00:00 +0800", "snippet": "This post is to show Markdown syntax rendering on Chirpy, you can also use it as an example of writing. Now, let’s start looking at text and typography.TitlesH1 - headingH2 - headingH3 - headingH4 - headingParagraphI wandered lonely as a cloudThat floats on high o’er vales and hills,When all at once I saw a crowd,A host, of golden daffodils;Beside the lake, beneath the trees,Fluttering and dancing in the breeze.ListsOrdered list Firstly Secondly ThirdlyUnordered list Chapter Section Paragraph Task list TODO Completed Defeat COVID-19 Vaccine production Economic recovery People smile again Description list Sun the star around which the earth orbits Moon the natural satellite of the earth, visible by reflected light from the sunBlock Quote This line shows the block quote.Prompts An example showing the tip type prompt. An example showing the info type prompt. An example showing the warning type prompt. An example showing the danger type prompt.Tables Company Contact Country Alfreds Futterkiste Maria Anders Germany Island Trading Helen Bennett UK Magazzini Alimentari Riuniti Giovanni Rovelli Italy Linkshttp://127.0.0.1:4000FootnoteClick the hook will locate the footnote1, and here is another footnote2.Mermaid SVG gantt title Adding GANTT diagram functionality to mermaid apple :a, 2017-07-20, 1w banana :crit, b, 2017-07-23, 1d cherry :active, c, after b a, 1dMathematicsThe mathematics powered by MathJax:\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]When $a \\ne 0$, there are two solutions to $ax^2 + bx + c = 0$ and they are\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\\]Inline codeThis is an example of Inline Code.FilepathHere is the /path/to/the/file.extend.Code blockCommonThis is a common code snippet, without syntax highlight and line number.Specific LanguagesConsole$ env |grep SHELLSHELL=/usr/local/bin/bashPYENV_SHELL=bashShellif [ $? -ne 0 ]; then echo \"The command was not successful.\"; #do the needful / exitfi;Specific filename@import \"colors/light-typography\", \"colors/dark-typography\"Reverse Footnote The footnote source &#8617; The 2nd footnote source &#8617; " } ]
