<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>sa1tycat</title><subtitle>this is just my blog.</subtitle> <updated>2023-01-10T23:10:27+08:00</updated> <author> <name>saltycat</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 saltycat </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>test</title><link href="/posts/test2/" rel="alternate" type="text/html" title="test" /><published>2022-10-18T20:45:23+08:00</published> <updated>2022-10-18T20:45:23+08:00</updated> <id>/posts/test2/</id> <content src="/posts/test2/" /> <author> <name>saltycat</name> </author> <summary> this is a test2 $x, y$ </summary> </entry> <entry><title>test</title><link href="/posts/test/" rel="alternate" type="text/html" title="test" /><published>2022-10-18T20:45:23+08:00</published> <updated>2023-01-10T23:09:49+08:00</updated> <id>/posts/test/</id> <content src="/posts/test/" /> <author> <name>saltycat</name> </author> <summary> this is a test $x, y ![16641673349112.pic](/assets/blog_res/2022-10-18-test.assets/16641673349112.pic.jpg) </summary> </entry> <entry><title>1，2，3，4 依次入栈的出栈排列问题</title><link href="/posts/stack-combinatory/" rel="alternate" type="text/html" title="1，2，3，4 依次入栈的出栈排列问题" /><published>2022-10-18T20:45:23+08:00</published> <updated>2023-01-10T22:56:09+08:00</updated> <id>/posts/stack-combinatory/</id> <content src="/posts/stack-combinatory/" /> <author> <name>saltycat</name> </author> <category term="算法" /> <category term="数据结构" /> <summary> </summary> </entry> <entry><title>时间复杂度</title><link href="/posts/time-complexity/" rel="alternate" type="text/html" title="时间复杂度" /><published>2022-08-31T19:26:17+08:00</published> <updated>2022-09-10T21:09:29+08:00</updated> <id>/posts/time-complexity/</id> <content src="/posts/time-complexity/" /> <author> <name>saltycat</name> </author> <category term="算法" /> <summary> 记号 大 O 记号 用于描述一个函数的渐进上界。 具体地，若存在正的常数 $c$ 和函数 $f(n)$，使得对任何 $n \gg 2$ 都有 $T(n) \leq c\cdot f(n)$ 则可认为在 $n$ 足够大之后，$f(n)$ 给出了 $T(n)$ 增长速度的一个渐进上界。此时，记之为： $T(n) = \mathcal{O}(f(n))$。 其性质： 对于任一常数 $c &amp;gt; 0$，有 $\mathcal{O}(f(n)) = \mathcal{O}(c\cdot f(n))$ 对于任意常数 $a &amp;gt; b &amp;gt; 0$，有 $\mathcal{O}(n^a + n^b) = \mathcal{O}(n^a)$ 从而可知大 O 记号将正的常数认定为 1，并且忽略除最高次项的其他项。 由于大 O 记号用于刻画的是一个函数的渐进上界，对于时间... </summary> </entry> <entry><title>快速幂</title><link href="/posts/binary-exponentiation/" rel="alternate" type="text/html" title="快速幂" /><published>2022-08-21T20:05:17+08:00</published> <updated>2022-09-01T20:42:45+08:00</updated> <id>/posts/binary-exponentiation/</id> <content src="/posts/binary-exponentiation/" /> <author> <name>saltycat</name> </author> <category term="算法" /> <summary> 引言 在计算指数如 $7^5$ 时，最朴素的做法就是逐个累乘，即： long long ans = 1; for (int i = 1; i &amp;lt;= 5; i++) { ans *= 7; } 显然算法的时间复杂度为 $\mathcal{O}(n)$，效率虽然也是可以接受的，但显然其中有很多部分是属于重复操作的。 例如我们计算出了 $7^2$，显然这个结果还可以继续使用，即$7^4=(7^2)^2$，从而计算 $7^5=(7^2)^2\times7$。 再举一个指数稍微大一点的例子，如 $7^8$，要计算 $7^8$，我们可以先计算出 $7^4$ 然后再平方；要计算 $7^4$，我们可以先计算 $7^2$，然后再平方；…，如此往复直到幂指数为 0，直接返回结果为 1。 递归版 从而可以总结出如下递归式： \[\textup{power}(a,n)=\le... </summary> </entry> </feed>
